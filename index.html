<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic VDT Calculator - Table View</title>
    <!-- Add Chart.js libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <!-- Add SortableJS for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f7f9;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 1600px; /* Wider container for table */
            margin: auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .header-container {
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            font-weight: 600;
            margin: 0;
            display: inline-block;
        }
        .header-actions {
            position: absolute;
            top: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .patient-id-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        .patient-id-container label { font-size: 1.2em; font-weight: 500; color: #34495e; }
        .patient-id-container input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1.1em; width: 250px; }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .left-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 15px;
            height: 36px;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .compact-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 1.6em;
            line-height: 36px;
        }
        .add-row-btn { background-color: #27ae60; }
        .remove-row-btn { background-color: #e74c3c; }
        .remove-row-btn:disabled { background-color: #bdc3c7; cursor: not-allowed; opacity: 0.6; }
        .manage-btn { background-color: #34495e; }
        
        .sort-control, .new-nodule-control { display: flex; align-items: center; gap: 8px; vertical-align: middle; }
        .sort-control label, .new-nodule-control label { font-weight: 500; }
        .sort-control select { padding: 8px; border-radius: 5px; border: 1px solid #ccc; font-size: 1em; }
        .new-nodule-control input[type="checkbox"] { width: 18px; height: 18px; }


        .data-table-wrapper { overflow-x: auto; }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
        }
        .data-table th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table tbody tr:nth-child(even) { background-color: #f9f9f9; }
        .data-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            text-align: center;
            min-width: 120px;
        }
        
        .total-results-container, .prediction-results-container {
            display: flex;
            justify-content: space-around;
            padding: 20px;
            background-color: #eaf5ff;
            border-radius: 8px;
            margin-top: 20px;
        }
        .prediction-results-container {
            background-color: #fef9e7;
            border: 1px solid #f1c40f;
        }
        .total-result-box, .prediction-result-box { text-align: center; flex: 1; display: flex; flex-direction: column; align-items: center; gap: 10px;}
        .total-result-box .label, .prediction-result-box .label { font-size: 1em; font-weight: 600; color: #31708f; margin-bottom: 0; }
        .prediction-result-box .label { color: #876404; }
        .total-result-box .value { font-size: 1.4em; }
        .prediction-result-box .value { font-size: 1.2em; font-weight: bold; color: #333; }
        
        .main-actions { display: flex; gap: 10px; flex-wrap: wrap; }
        .save-btn { background-color: #9b59b6; }
        .clear-btn { background-color: #f39c12; }
        .export-new-btn { background-color: #8e44ad; }
        .export-btn { background-color: #16a085; }
        .copy-btn { background-color: #3498db; padding: 5px 15px; height: auto; font-size: 0.9em; width: auto; }


        .chart-container {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            height: 450px;
            position: relative;
        }

        /* Color coding */
        .vdt-positive { color: #d9534f; }
        .vdt-indeterminate { color: #f0ad4e; }
        .vdt-fast-shrinking { color: #337ab7; }
        .vdt-stable-or-slow { color: #2c3e50; }
        .extra-info { font-size: 0.8em; font-weight: normal; color: #555; display: block; margin-top: 4px; }
        .result-cell strong, .total-result-box strong { font-weight: 900; }
        .hidden { display: none !important; }

        /* Tooltip Styles */
        .tooltip-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background-color: #7f8c8d;
            color: white;
            font-size: 11px;
            line-height: 16px;
            text-align: center;
            font-weight: bold;
            cursor: pointer;
            margin-left: 2px;
            vertical-align: super; /* Makes it a superscript */
        }
        .tooltip-text {
            visibility: hidden;
            width: 280px;
            background-color: #34495e;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.9em;
            line-height: 1.4;
        }
        .tooltip-text.visible {
            visibility: visible;
            opacity: 1;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }

        /* Drag and Drop Styles */
        .drag-handle {
            cursor: grab;
            font-size: 20px;
            color: #95a5a6;
        }
        .drag-handle:active {
            cursor: grabbing;
        }
        .delete-row-btn {
            background: none;
            border: none;
            color: #e74c3c;
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
        }
        .row-controls {
            width: 30px;
            min-width: 30px;
            padding: 0 5px;
        }
        .scan-number-col {
            width: 60px;
            min-width: 60px;
        }
        
        /* Patient Manager Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .modal-header h2 { margin: 0; color: #2c3e50;}
        .modal-close-btn { font-size: 28px; font-weight: bold; color: #7f8c8d; cursor: pointer; background: none; border: none; }
        .patient-list-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }
        .patient-list-controls input[type="search"] {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 300px;
            font-size: 1em;
        }
        .patient-list-table {
            width: 100%;
            border-collapse: collapse;
        }
        .patient-list-table th, .patient-list-table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle;
        }
        .patient-list-table th { background-color: #f2f2f2; }
        .star-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #bdc3c7; /* Default color for empty star */
        }
        .star-btn.starred {
            color: #f1c40f;
        }
        .notes-area {
            width: 100%;
            min-height: 40px;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
            resize: vertical;
        }
        .patient-actions {
            display: flex;
            gap: 5px;
        }
        .patient-actions .control-btn {
             font-size: 0.8em;
             height: 30px;
             padding: 0 10px;
        }

    </style>
</head>
<body>

    <div class="container">
        <div class="header-container">
            <h1>Dynamic VDT Calculator</h1>
            <div class="header-actions">
                <button class="control-btn manage-btn" id="manage-patients-btn">Worklist</button>
                <button class="control-btn export-btn" id="export-btn">Export CSV (All)</button>
            </div>
        </div>
        
        <div class="patient-id-container">
            <label for="patient-id">Patient ID:</label>
            <input type="text" id="patient-id" placeholder="Enter Patient ID to Load/Save">
        </div>

        <div class="table-controls">
            <div class="left-controls">
                <button class="control-btn add-row-btn" id="add-scan-btn">Add Scan</button>
                <div class="sort-control">
                    <label for="sort-order">Display Order:</label>
                    <select id="sort-order">
                        <option value="newest_first" selected>Newest First</option>
                        <option value="oldest_first">Oldest First</option>
                    </select>
                    <span class="tooltip-icon" data-tooltip="Changes the display order of the scan data in the table. The actual scan numbering (Scan 0, -1, etc.) is always based on the chronological date, regardless of this setting.">?</span>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="new-nodule-checkbox">
                    <label for="new-nodule-checkbox">New Nodule (VDTmax)</label>
                    <span class="tooltip-icon" data-tooltip="For newly discovered nodules with no prior scan history. When checked, the calculator assumes a pre-discovery volume of 15mm³ to calculate the maximum possible VDT (VDTmax) for the first follow-up interval.">?</span>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="log-scale-checkbox">
                    <label for="log-scale-checkbox">Log Scale (Y-Axis)</label>
                    <span class="tooltip-icon" data-tooltip="Switches the chart's Y-axis (Volume) to a logarithmic scale. This is useful for visualizing growth trends more clearly when volume changes are large (e.g., from tens to thousands).">?</span>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="prediction-checkbox">
                    <label for="prediction-checkbox">Prediction</label>
                    <span class="tooltip-icon" data-tooltip="Based on the existing data and the calculated total VDT, this feature projects and displays the nodule's potential volume at 3 months and 1 year in the future on the chart, helping to assess its growth trajectory.">?</span>
                </div>
            </div>
            <div class="main-actions">
                <button class="control-btn clear-btn" id="clear-btn">Clear</button>
                <button class="control-btn save-btn" id="save-btn">Save</button>
                <button class="control-btn export-new-btn" id="export-new-btn">Save & New</button>
            </div>
        </div>

        <div class="data-table-wrapper">
            <table class="data-table" id="data-table">
                <thead>
                    <tr>
                        <th class="row-controls"></th>
                        <th class="scan-number-col">Scan #</th>
                        <th>Scan Date</th>
                        <th>Solid (mm³)</th>
                        <th>Solid core (mm³)</th>
                        <th>Non-solid (mm³)</th>
                        <th>VDT</th>
                        <th>VDT<sub>core</sub></th>
                        <th>VDT<sub>GGO</sub></th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Rows will be dynamically inserted here -->
                </tbody>
            </table>
        </div>

        <div class="total-results-container" id="total-results-container">
             <!-- Total VDT results will be displayed here -->
        </div>

        <div class="prediction-results-container hidden" id="prediction-results-container">
            <!-- Prediction results will be displayed here -->
        </div>

        <div class="chart-container">
            <canvas id="volumeChart"></canvas>
        </div>
    </div>
    
    <!-- Patient Manager Modal -->
    <div id="patient-manager-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Patient Management Center</h2>
                <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            </div>
            <div class="patient-list-controls">
                <input type="search" id="patient-search-input" placeholder="Search by Patient ID...">
                <div class="new-nodule-control">
                    <input type="checkbox" id="show-starred-only">
                    <label for="show-starred-only">Show Starred Only</label>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="show-positive-only">
                    <label for="show-positive-only">Show VDT Positive Only</label>
                </div>
                 <div class="new-nodule-control">
                    <input type="checkbox" id="show-new-nodule-only">
                    <label for="show-new-nodule-only">Show New Nodules Only</label>
                </div>
            </div>
            <div class="data-table-wrapper">
                <table class="patient-list-table">
                    <thead>
                        <tr>
                            <th>Star</th>
                            <th>Patient ID</th>
                            <th>Total VDT</th>
                            <th>Total VDT<sub>core</sub></th>
                             <th>Total VDT<sub>GGO</sub></th>
                            <th style="width: 30%;">Notes</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="patient-list-body">
                        <!-- Patient list will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Global variables ---
            const tableBody = document.getElementById('table-body');
            const addScanBtn = document.getElementById('add-scan-btn');
            const clearBtn = document.getElementById('clear-btn');
            const saveBtn = document.getElementById('save-btn');
            const exportBtn = document.getElementById('export-btn');
            const exportNewBtn = document.getElementById('export-new-btn');
            const patientIdInput = document.getElementById('patient-id');
            const totalResultsContainer = document.getElementById('total-results-container');
            const predictionResultsContainer = document.getElementById('prediction-results-container');
            const sortOrderSelect = document.getElementById('sort-order');
            const newNoduleCheckbox = document.getElementById('new-nodule-checkbox');
            const logScaleCheckbox = document.getElementById('log-scale-checkbox');
            const predictionCheckbox = document.getElementById('prediction-checkbox');
            const chartCanvas = document.getElementById('volumeChart');
            const container = document.querySelector('.container');
            
            // Patient Manager Modal elements
            const managePatientsBtn = document.getElementById('manage-patients-btn');
            const patientManagerModal = document.getElementById('patient-manager-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const patientListBody = document.getElementById('patient-list-body');
            const patientSearchInput = document.getElementById('patient-search-input');
            const showStarredOnlyCheckbox = document.getElementById('show-starred-only');
            const showPositiveOnlyCheckbox = document.getElementById('show-positive-only');
            const showNewNoduleOnlyCheckbox = document.getElementById('show-new-nodule-only');

            let tooltipDiv = null;
            let sortableInstance = null;
            
            let uniqueRowId = 0;
            let tableData = [];
            let isPasting = false;
            let volumeChart = null;

            // --- Tooltip Functions ---
            function createTooltip() {
                if (!tooltipDiv) {
                    tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'tooltip-text';
                    container.appendChild(tooltipDiv);
                }
            }

            function showTooltip(target, text) {
                if (!tooltipDiv) createTooltip();
                
                tooltipDiv.innerHTML = text;
                tooltipDiv.classList.add('visible'); // Make it visible first to calculate its size

                const rect = target.getBoundingClientRect();
                const containerRect = container.getBoundingClientRect();
                
                let top = rect.top - containerRect.top - tooltipDiv.offsetHeight - 10;
                let left = rect.left - containerRect.left + (rect.width / 2) - (tooltipDiv.offsetWidth / 2);

                if (top < 0) {
                    top = rect.bottom - containerRect.top + 10;
                }
                if (left < 0) {
                    left = 5;
                }
                if (left + tooltipDiv.offsetWidth > container.clientWidth) {
                    left = container.clientWidth - tooltipDiv.offsetWidth - 5;
                }

                tooltipDiv.style.top = `${top}px`;
                tooltipDiv.style.left = `${left}px`;
            }

            function hideTooltip() {
                if (tooltipDiv) {
                    tooltipDiv.classList.remove('visible');
                }
            }

            // --- Core Functions (renderTable, updateScanNumbers, etc.) ---
            function renderTable() {
                const sortOrder = sortOrderSelect.value;
                const sortedData = [...tableData].sort((a, b) => {
                    const dateA = parseDateString(a.date) || 0;
                    const dateB = parseDateString(b.date) || 0;
                    if (sortOrder === 'newest_first') return dateB - dateA;
                    return dateA - dateB;
                });

                tableBody.innerHTML = ''; // Clear table
                sortedData.forEach(dataRow => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = dataRow.id;
                    tr.innerHTML = `
                        <td class="row-controls">
                            <span class="drag-handle">⠿</span>
                            <button class="delete-row-btn" title="Delete this row">-</button>
                        </td>
                        <td class="scan-number scan-number-col">-</td>
                        <td><input type="text" class="date-input" value="${dataRow.date}"></td>
                        <td><input type="number" class="solid-input" value="${dataRow.solid}"></td>
                        <td><input type="number" class="core-input" value="${dataRow.core}"></td>
                        <td><input type="number" class="nonsolid-input" value="${dataRow.nonsolid || ''}"></td>
                        <td class="result-cell vdt-solid-result">-</td>
                        <td class="result-cell vdt-core-result">-</td>
                        <td class="result-cell vdt-ggo-result">-</td>
                    `;
                    tableBody.appendChild(tr);
                });
                
                initializeSortable();
                bindEventListeners();
                updateScanNumbers();
                calculateAll();
            }

            function initializeSortable() {
                if (sortableInstance) {
                    sortableInstance.destroy();
                }
                sortableInstance = new Sortable(tableBody, {
                    handle: '.drag-handle',
                    animation: 150,
                    onEnd: function (evt) {
                        const newOrderedIds = Array.from(tableBody.querySelectorAll('tr')).map(tr => parseInt(tr.dataset.id));
                        
                        // Reorder the master tableData array to match the new visual order
                        tableData.sort((a, b) => newOrderedIds.indexOf(a.id) - newOrderedIds.indexOf(b.id));

                        // Recalculate everything. This automatically handles re-numbering scans.
                        calculateAll(); 
                    },
                });
            }

            function updateScanNumbers() {
                // We need to calculate based on the true chronological order, not the display order
                const chronoData = [...tableData]
                    .map(d => ({...d, dateObj: parseDateString(d.date)}))
                    .filter(d => d.dateObj)
                    .sort((a, b) => b.dateObj - a.dateObj); // Newest date first

                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const rowId = parseInt(row.dataset.id);
                    const chronoIndex = chronoData.findIndex(d => d.id === rowId);
                    
                    const scanNumCell = row.querySelector('.scan-number');
                    if (chronoIndex !== -1) {
                         scanNumCell.textContent = chronoIndex === 0 ? 'Scan 0' : `Scan -${chronoIndex}`;
                    } else {
                        scanNumCell.textContent = '-'; // No date, no number
                    }
                });
            }
            
            function addScan() {
                tableData.push({ id: uniqueRowId++, date: '', solid: '', core: '', nonsolid: '' });
                renderTable();
            }

            function deleteRow(rowId) {
                if (tableData.length > 0) {
                    tableData = tableData.filter(d => d.id !== rowId);
                    renderTable();
                }
            }


            function clearAll() {
                patientIdInput.value = '';
                tableData = [];
                newNoduleCheckbox.checked = false;
                logScaleCheckbox.checked = false;
                predictionCheckbox.checked = false;
                initializeApp();
            }

            // --- Data Persistence (Save/Load) ---
            function saveData() {
                const patientId = patientIdInput.value.trim();
                if (!patientId) {
                    alert('Please enter a Patient ID to save the session.');
                    return false;
                }
                
                // Fetch existing extra data to not overwrite it
                let existingData = {};
                const savedDataString = localStorage.getItem(`vdt-calc-${patientId}`);
                if (savedDataString) {
                    existingData = JSON.parse(savedDataString);
                }

                const dataToSave = {
                    ...existingData, // Preserve notes and starred status
                    tableData: tableData,
                    isNewNodule: newNoduleCheckbox.checked,
                    isLogScale: logScaleCheckbox.checked,
                    isPrediction: predictionCheckbox.checked,
                };
                localStorage.setItem(`vdt-calc-${patientId}`, JSON.stringify(dataToSave));
                
                const originalText = saveBtn.textContent;
                saveBtn.textContent = 'Saved!';
                saveBtn.classList.add('add-row-btn'); // Use green color for success
                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.classList.remove('add-row-btn');
                }, 2000);
                return true;
            }

            function loadData(pId) {
                const patientId = pId || patientIdInput.value.trim();
                if (!patientId) return;

                const savedDataString = localStorage.getItem(`vdt-calc-${patientId}`);
                if (savedDataString) {
                    const savedData = JSON.parse(savedDataString);
                    patientIdInput.value = patientId;
                    tableData = savedData.tableData;
                    uniqueRowId = tableData.length > 0 ? Math.max(...tableData.map(d => d.id)) + 1 : 0;
                    newNoduleCheckbox.checked = savedData.isNewNodule;
                    logScaleCheckbox.checked = savedData.isLogScale || false;
                    predictionCheckbox.checked = savedData.isPrediction || false;
                    renderTable();
                }
            }

            function saveAndNew() {
                if(saveData()) {
                    clearAll();
                }
            }
            
            // --- Event Handlers (Paste, Input) ---
            function handlePaste(event) {
                 isPasting = true;
                event.preventDefault();
                const pasteData = (event.clipboardData || window.clipboardData).getData('text');
                const rows = pasteData.split(/[\r\n]+/).filter(r => r.trim() !== '').map(r => r.split('\t'));
                
                const startCell = event.target;
                const startRowElement = startCell.closest('tr');
                
                const allRenderedRows = Array.from(tableBody.querySelectorAll('tr'));
                const startRenderedIndex = allRenderedRows.findIndex(row => row === startRowElement);

                const inputs = ['date', 'solid', 'core', 'nonsolid'];
                const startInputClass = Array.from(startCell.classList).find(c => c.includes('-input'));
                const startInputIndex = inputs.indexOf(startInputClass.split('-')[0]);

                const sortedIds = allRenderedRows.map(row => parseInt(row.dataset.id));

                rows.forEach((rowData, rowIndex) => {
                    const targetRenderedIndex = startRenderedIndex + rowIndex;
                    let currentRowData;

                    if (targetRenderedIndex < sortedIds.length) {
                        const targetRowId = sortedIds[targetRenderedIndex];
                        currentRowData = tableData.find(d => d.id === targetRowId);
                    } else {
                        const newRow = { id: uniqueRowId++, date: '', solid: '', core: '', nonsolid: '' };
                        tableData.push(newRow);
                        currentRowData = newRow;
                    }
                    
                    rowData.forEach((cellData, colIndex) => {
                        const currentInputIndex = startInputIndex + colIndex;
                        if (currentInputIndex < inputs.length && currentRowData) {
                            currentRowData[inputs[currentInputIndex]] = cellData.trim();
                        }
                    });
                });
                
                renderTable();
                setTimeout(() => { isPasting = false; }, 100);
            }

            function bindEventListeners() {
                tableBody.querySelectorAll('tr').forEach(tr => {
                    const rowId = parseInt(tr.dataset.id);
                    tr.querySelector('.date-input').addEventListener('input', (e) => updateData(e, 'date'));
                    tr.querySelector('.solid-input').addEventListener('input', (e) => updateData(e, 'solid'));
                    tr.querySelector('.core-input').addEventListener('input', (e) => updateData(e, 'core'));
                    tr.querySelector('.nonsolid-input').addEventListener('input', (e) => updateData(e, 'nonsolid'));
                    
                    tr.querySelector('.delete-row-btn').addEventListener('click', () => deleteRow(rowId));

                    const dateInput = tr.querySelector('.date-input');
                    dateInput.addEventListener('blur', (e) => { format_date(e); updateData(e, 'date'); });
                    dateInput.addEventListener('focus', unformat_date);

                    tr.querySelectorAll('input').forEach(input => {
                        input.addEventListener('paste', handlePaste);
                    });
                });
            }
            
            function updateData(event, key) {
                if (isPasting) return;
                const rowId = parseInt(event.target.closest('tr').dataset.id);
                const dataRow = tableData.find(d => d.id === rowId);
                if (dataRow) dataRow[key] = event.target.value;
                calculateAll();
            }

            function format_date(event) {
                 let value = event.target.value.replace(/-/g, '');
                if (value.length === 8 && !isNaN(value)) {
                    event.target.value = `${value.substring(0, 4)}-${value.substring(4, 6)}-${value.substring(6, 8)}`;
                }
            }
            function unformat_date(event) { event.target.value = event.target.value.replace(/-/g, ''); }
            function parseDateString(dateStr) {
                if (!dateStr) return null;
                const cleanStr = dateStr.replace(/-/g, '');
                if (cleanStr.length !== 8 || isNaN(cleanStr)) return null;
                return new Date(parseInt(cleanStr.substring(0, 4)), parseInt(cleanStr.substring(4, 6)) - 1, parseInt(cleanStr.substring(6, 8)));
            }

            // --- Calculation Engine ---
            function calculateSingleVDT(vol1, vol2, timeDiff) {
                const baseReturn = { html: '-', value: null, timeDiff: null, volumeChange: null };
                if (timeDiff === null || timeDiff <= 0 || isNaN(vol1) || isNaN(vol2) || vol1 <= 0 || vol2 <= 0) { return baseReturn; }
                
                const volumeChange = ((vol1 - vol2) / vol2) * 100;
                if (vol1 === vol2) { return { html: `<span class="vdt-stable-or-slow">Stable</span>`, value: 'Stable', timeDiff: timeDiff.toFixed(0), volumeChange: volumeChange.toFixed(1) }; }
                
                const vdt = (Math.log(2) * timeDiff) / (Math.log(vol1) - Math.log(vol2));
                const displayValue = vdt.toFixed(0);
                let className = 'vdt-stable-or-slow';
                if (vdt > 0 && vdt <= 400) className = 'vdt-positive';
                else if (vdt > 400 && vdt <= 600) className = 'vdt-indeterminate';
                else if (vdt < 0 && vdt >= -400) className = 'vdt-fast-shrinking';
                return { html: `<strong><span class="${className}">${displayValue}d</span></strong>`, value: displayValue, timeDiff: timeDiff.toFixed(0), volumeChange: volumeChange.toFixed(1) };
            }

            function calculateAll() {
                 const isNewNodule = newNoduleCheckbox.checked;
                const dataForCalc = tableData
                    .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) }))
                    .filter(d => d.dateObj)
                    .sort((a, b) => a.dateObj - b.dateObj);

                document.querySelectorAll('.result-cell').forEach(cell => cell.innerHTML = '-');

                function createResultHTML(result, isMax = false) {
                    if (result.value === null) return '-';
                    const maxSuffix = isMax ? ' <small>(max)</small>' : '';
                    const volChangeFormatted = `${result.volumeChange > 0 ? '+' : ''}${result.volumeChange}%`;
                    return `${result.html}${maxSuffix}<div class="extra-info">${result.timeDiff}d | ${volChangeFormatted}</div>`;
                }
                
                let firstIntervalSolidResult, firstIntervalCoreResult, firstIntervalGgoResult;
                for (let i = 1; i < dataForCalc.length; i++) {
                    const prevScan = dataForCalc[i - 1];
                    const currScan = dataForCalc[i];
                    const isFirstInterval = (i === 1);
                    const isMaxCalc = isFirstInterval && isNewNodule;
                    const prevSolid = isMaxCalc ? 15 : prevScan.solid;
                    const prevCore = isMaxCalc ? 15 : prevScan.core;
                    const prevNonsolid = isMaxCalc ? 15 : prevScan.nonsolid;


                    const timeDiff = (currScan.dateObj - prevScan.dateObj) / (1000 * 60 * 60 * 24);

                    const solidResult = calculateSingleVDT(currScan.solid, prevSolid, timeDiff);
                    const coreResult = calculateSingleVDT(currScan.core, prevCore, timeDiff);
                    const ggoResult = calculateSingleVDT(currScan.nonsolid, prevNonsolid, timeDiff);
                    
                    if(isFirstInterval) {
                        firstIntervalSolidResult = solidResult;
                        firstIntervalCoreResult = coreResult;
                        firstIntervalGgoResult = ggoResult;
                    }
                    
                    const targetRow = Array.from(tableBody.querySelectorAll('tr')).find(row => parseInt(row.dataset.id) === currScan.id);
                    if(targetRow){
                        targetRow.querySelector('.vdt-solid-result').innerHTML = createResultHTML(solidResult, isMaxCalc);
                        targetRow.querySelector('.vdt-core-result').innerHTML = createResultHTML(coreResult, isMaxCalc);
                        targetRow.querySelector('.vdt-ggo-result').innerHTML = createResultHTML(ggoResult, isMaxCalc);
                    }
                }

                let totalSolidResult, totalCoreResult, totalGgoResult;
                if (dataForCalc.length > 1) {
                    const firstForTotal = (isNewNodule && dataForCalc.length > 1) ? dataForCalc[1] : dataForCalc[0];
                    const last = dataForCalc[dataForCalc.length - 1];
                    
                    const totalTimeDiff = (last.dateObj - firstForTotal.dateObj) / (1000 * 60 * 60 * 24);

                    totalSolidResult = calculateSingleVDT(last.solid, firstForTotal.solid, totalTimeDiff);
                    totalCoreResult = calculateSingleVDT(last.core, firstForTotal.core, totalTimeDiff);
                    totalGgoResult = calculateSingleVDT(last.nonsolid, firstForTotal.nonsolid, totalTimeDiff);
                    
                    totalResultsContainer.innerHTML = `
                        <div class="total-result-box">
                            <div class="label">Total VDT</div>
                            <div class="value">${createResultHTML(totalSolidResult)}</div>
                            <button class="control-btn copy-btn" data-type="solid">Copy Solid Report</button>
                        </div>
                        <div class="total-result-box">
                            <div class="label">Total VDT<sub>core</sub></div>
                            <div class="value">${createResultHTML(totalCoreResult)}</div>
                            <button class="control-btn copy-btn" data-type="core">Copy Core Report</button>
                        </div>
                        <div class="total-result-box">
                            <div class="label">Total VDT<sub>GGO</sub></div>
                            <div class="value">${createResultHTML(totalGgoResult)}</div>
                            <button class="control-btn copy-btn" data-type="nonsolid">Copy Non-solid Report</button>
                        </div>`;
                    
                    document.querySelectorAll('.copy-btn').forEach(btn => {
                        btn.addEventListener('click', (event) => copyReport(event.target.dataset.type, event));
                    });

                } else {
                    totalResultsContainer.innerHTML = '';
                }
                
                // Prediction Logic
                if (predictionCheckbox.checked && dataForCalc.length > 0) {
                    predictionResultsContainer.classList.remove('hidden');
                    const last = dataForCalc[dataForCalc.length - 1];
                    let vdtForSolidPrediction = totalSolidResult;
                    let vdtForCorePrediction = totalCoreResult;
                    let vdtForGgoPrediction = totalGgoResult;

                    if (isNewNodule && dataForCalc.length === 2) {
                        vdtForSolidPrediction = firstIntervalSolidResult;
                        vdtForCorePrediction = firstIntervalCoreResult;
                        vdtForGgoPrediction = firstIntervalGgoResult;
                    }
                    
                    const predict = (vdtResult, lastVol) => {
                        if (!vdtResult || !vdtResult.value || vdtResult.value === 'Stable' || isNaN(lastVol)) return { m3: 'N/A', y1: 'N/A' };
                        const vdt = parseFloat(vdtResult.value);
                        if (vdt <= 0) return { m3: 'N/A', y1: 'N/A' };
                        const m3Vol = lastVol * Math.pow(2, 90 / vdt);
                        const y1Vol = lastVol * Math.pow(2, 365 / vdt);
                        return { m3: m3Vol.toFixed(1), y1: y1Vol.toFixed(1) };
                    };

                    const solidPrediction = predict(vdtForSolidPrediction, last.solid);
                    const corePrediction = predict(vdtForCorePrediction, last.core);
                    const ggoPrediction = predict(vdtForGgoPrediction, last.nonsolid);

                    predictionResultsContainer.innerHTML = `
                        <div class="prediction-result-box">
                            <div class="label">Solid Prediction (3m / 1yr)</div>
                            <div class="value">${solidPrediction.m3} / ${solidPrediction.y1} mm³</div>
                        </div>
                        <div class="prediction-result-box">
                            <div class="label">Solid Core Prediction (3m / 1yr)</div>
                            <div class="value">${corePrediction.m3} / ${corePrediction.y1} mm³</div>
                        </div>
                        <div class="prediction-result-box">
                            <div class="label">Non-solid Prediction (3m / 1yr)</div>
                            <div class="value">${ggoPrediction.m3} / ${ggoPrediction.y1} mm³</div>
                        </div>
                    `;

                } else {
                    predictionResultsContainer.classList.add('hidden');
                }

                renderChart(dataForCalc, totalSolidResult, totalCoreResult, totalGgoResult);
                updateScanNumbers();
            }

            function renderChart(data, totalSolidResult, totalCoreResult, totalGgoResult) {
                if (volumeChart) {
                    volumeChart.destroy();
                }

                const ctx = chartCanvas.getContext('2d');
                const isNewNodule = newNoduleCheckbox.checked;
                const useLogScale = logScaleCheckbox.checked;
                const usePrediction = predictionCheckbox.checked;
                
                let chartData = [...data];
                if (isNewNodule && chartData.length > 0) {
                     chartData[0] = { ...chartData[0], solid: 15, core: 15, nonsolid: 15 };
                }

                const validDataPoints = chartData.filter(d => d.dateObj && (!isNaN(d.solid) || !isNaN(d.core) || !isNaN(d.nonsolid)));

                if (validDataPoints.length < 1) {
                    ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                    return;
                }
                
                const annotations = [];
                // Interval Annotations (simplified for brevity, you would extend this)
                // ...
                
                const datasets = [
                    {
                        label: 'Solid',
                        data: chartData.map(d => ({ x: d.dateObj, y: isNaN(d.solid) ? null : d.solid })),
                        borderColor: 'rgb(54, 162, 235)', backgroundColor: 'rgba(54, 162, 235, 0.5)', tension: 0.1,
                        datalabels: { align: 'top', /* ... */ }
                    },
                    {
                        label: 'Solid core',
                        data: chartData.map(d => ({ x: d.dateObj, y: isNaN(d.core) ? null : d.core })),
                        borderColor: 'rgb(255, 99, 132)', backgroundColor: 'rgba(255, 99, 132, 0.5)', tension: 0.1,
                         datalabels: { align: 'bottom', /* ... */ }
                    },
                    {
                        label: 'Non-solid',
                        data: chartData.map(d => ({ x: d.dateObj, y: isNaN(d.nonsolid) ? null : d.nonsolid })),
                        borderColor: 'rgb(40, 167, 69)', backgroundColor: 'rgba(40, 167, 69, 0.5)', tension: 0.1,
                         datalabels: { align: 'center', /* ... */ }
                    }
                ];

                // Add Total VDT and Prediction datasets
                // ... (This part needs to be extended to include nonsolid)

                const allVolumes = datasets.flatMap(ds => ds.data.map(p => p.y)).filter(v => v !== null && !isNaN(v));
                let yMin = Math.min(...allVolumes);
                let yMax = Math.max(...allVolumes);
                const padding = (yMax - yMin) * 0.2 || 10;
                yMin = yMin > padding ? yMin - padding : 0;
                yMax = yMax + padding;

                volumeChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: { datasets },
                    options: { /* ... options ... */ }
                });
            }

            function exportToCSV(isExportAll = false) {
                // ... (extend for nonsolid)
            }
            
            function copyReport(type, event) {
                const isNewNodule = newNoduleCheckbox.checked;
                const dataForCalc = tableData
                    .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) }))
                    .filter(d => d.dateObj) 
                    .sort((a, b) => b.dateObj - a.dateObj); 
                
                if (dataForCalc.length < 1) return;

                const numScans = dataForCalc.length;
                const numCols = numScans > 1 ? numScans * 2 - 1 : 1;
                
                // --- Define Styles ---
                const tableStyle = `font-family: Arial; font-size: 11pt; border-collapse: collapse; border-spacing: 0; border: none; background-color: transparent; table-layout: fixed; width: ${numCols * 100}px;`;
                const cellStyle = `color: white; background-color: transparent; border: none; padding: 0.01in; text-align: center; height: 1em; line-height: 1.1;`;
                const emptyCellStyle = `border: none; padding: 0.01in; background-color: transparent;`;

                let html = `<table style="${tableStyle}">`;

                // --- Row 1: Total VDT ---
                if (numScans > 1) {
                    const chronoSortedTotal = [...dataForCalc].sort((a, b) => a.dateObj - b.dateObj);
                    const firstForTotal = (isNewNodule && chronoSortedTotal.length > 1) ? chronoSortedTotal[1] : chronoSortedTotal[0];
                    const last = chronoSortedTotal[chronoSortedTotal.length - 1];
                    const totalTimeDiff = (last.dateObj - firstForTotal.dateObj) / (1000 * 60 * 60 * 24);
                    
                    let vol1, vol2, label;
                    if (type === 'solid') {
                        vol1 = last.solid;
                        vol2 = firstForTotal.solid;
                        label = 'Total VDT';
                    } else if (type === 'core') {
                        vol1 = last.core;
                        vol2 = firstForTotal.core;
                        label = 'Total VDT<sub>core</sub>';
                    } else { // nonsolid
                        vol1 = last.nonsolid;
                        vol2 = firstForTotal.nonsolid;
                        label = 'Total VDT<sub>GGO</sub>';
                    }

                    const result = calculateSingleVDT(vol1, vol2, totalTimeDiff);
                    
                    let totalVdtDisplay = result.value ? `${result.value}d` : 'N/A';

                    if (result.value && result.value !== 'Stable') {
                        const vdtNum = parseFloat(result.value);
                        if (vdtNum > 0 && vdtNum <= 400) {
                            totalVdtDisplay = `<b style="color: red;">${totalVdtDisplay}</b>`;
                        } else if (vdtNum > 400 && vdtNum <= 600) {
                            totalVdtDisplay = `<b style="color: orange;">${totalVdtDisplay}</b>`;
                        } else {
                            totalVdtDisplay = `<b>${totalVdtDisplay}</b>`;
                        }
                    } else if (result.value) { // Handles "Stable" case
                         totalVdtDisplay = `<b>${totalVdtDisplay}</b>`;
                    }

                    html += `<tr><td colspan="${numCols}" style="${cellStyle}">${label}: ${totalVdtDisplay}</td></tr>`;
                }

                // --- Row 2 & 3: Scans and Volumes with separator columns ---
                let row2_scans = `<tr>`;
                let row3_volumes = `<tr>`;
                const chronoSorted = [...dataForCalc].sort((a, b) => a.dateObj - b.dateObj);

                dataForCalc.forEach((scan, i) => {
                    const scanNumber = `Scan ${i === 0 ? '0' : `-${i}`}`;
                    row2_scans += `<td style="${cellStyle}">${scanNumber}</td>`;
                    
                    let vol;
                    if (type === 'solid') {
                        vol = scan.solid;
                    } else if (type === 'core') {
                        vol = scan.core;
                    } else { // nonsolid
                        vol = scan.nonsolid;
                    }

                    const isOldestScan = scan.id === chronoSorted[0].id;
                    const volText = (isNewNodule && isOldestScan) ? `15 mm³ (A)` : (isNaN(vol) ? 'N/A' : `${vol.toFixed(0)} mm³`);
                    row3_volumes += `<td style="${cellStyle}">${volText}</td>`;

                    if (i < numScans - 1) {
                        row2_scans += `<td style="${emptyCellStyle}">&nbsp;</td>`;
                        row3_volumes += `<td style="${emptyCellStyle}">&nbsp;</td>`;
                    }
                });
                html += row2_scans + `</tr>` + row3_volumes + `</tr>`;

                // --- Row 4: Interval VDTs in separator columns ---
                if (numScans > 1) {
                    let row4_intervals = `<tr>`;
                    for (let i = 0; i < numScans - 1; i++) {
                        const currScan = dataForCalc[i]; // Newer scan
                        const prevScan = dataForCalc[i + 1]; // Older scan
                        
                        row4_intervals += `<td style="${emptyCellStyle}">&nbsp;</td>`;

                        const isFirstChronologicalInterval = (prevScan.id === chronoSorted[0].id && currScan.id === chronoSorted[1].id);
                        const isMaxCalc = isFirstChronologicalInterval && isNewNodule;
                        
                        let currVol, prevVol;
                        if (type === 'solid') {
                            currVol = currScan.solid;
                            prevVol = isMaxCalc ? 15 : prevScan.solid;
                        } else if (type === 'core') {
                            currVol = currScan.core;
                            prevVol = isMaxCalc ? 15 : prevScan.core;
                        } else { // nonsolid
                            currVol = currScan.nonsolid;
                            prevVol = isMaxCalc ? 15 : prevScan.nonsolid;
                        }

                        const timeDiff = (currScan.dateObj - prevScan.dateObj) / (1000 * 60 * 60 * 24);
                        const result = calculateSingleVDT(currVol, prevVol, timeDiff);
                        
                        let label;
                        if (type === 'solid') {
                            label = 'VDT';
                        } else if (type === 'core') {
                            label = 'VDT<sub>core</sub>';
                        } else { // nonsolid
                            label = 'VDT<sub>GGO</sub>';
                        }
                        if (isMaxCalc) {
                            label += '<sub>(max)</sub>';
                        }
                        
                        let vdtDisplay = result.value ? `${result.value}d` : 'N/A';
                        if (result.value && result.value !== 'Stable') {
                            const vdtNum = parseFloat(result.value);
                            if (vdtNum > 0 && vdtNum <= 400) {
                                vdtDisplay = `<b style="color: red;">${vdtDisplay}</b>`;
                            } else if (vdtNum > 400 && vdtNum <= 600) {
                                vdtDisplay = `<b style="color: orange;">${vdtDisplay}</b>`;
                            }
                        }

                        row4_intervals += `<td style="${cellStyle}">${label}: ${vdtDisplay}</td>`;
                    }
                    row4_intervals += `<td style="${emptyCellStyle}">&nbsp;</td>`;
                    html += row4_intervals + `</tr>`;
                }


                html += '</table>';
                
                const targetButton = event.target;
                const originalText = targetButton.textContent;

                function updateButtonOnSuccess() {
                    targetButton.textContent = 'Copied!';
                    targetButton.style.backgroundColor = '#27ae60';
                    setTimeout(() => {
                        targetButton.textContent = originalText;
                        targetButton.style.backgroundColor = '#3498db';
                    }, 2000);
                }
                
                // Fallback method for copying to clipboard
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px'; // Move it off-screen
                tempDiv.innerHTML = html;
                document.body.appendChild(tempDiv);
                
                let success = false;
                try {
                    const range = document.createRange();
                    range.selectNode(tempDiv);
                    window.getSelection().removeAllRanges(); // Clear previous selections
                    window.getSelection().addRange(range); // Select the content
                    
                    success = document.execCommand('copy');
                    
                    window.getSelection().removeAllRanges(); // Deselect
                } catch (err) {
                    console.error('Fallback copy method failed: ', err);
                }
                
                document.body.removeChild(tempDiv);

                if (success) {
                    updateButtonOnSuccess();
                } else {
                    console.error('Failed to copy: execCommand returned false or threw an error.');
                    alert('Failed to copy report.');
                }
            }
            
            // --- Patient Manager Functions ---
            function openPatientManager() {
                const searchTerm = patientSearchInput.value.toLowerCase();
                const showStarredOnly = showStarredOnlyCheckbox.checked;
                const showPositiveOnly = showPositiveOnlyCheckbox.checked;
                const showNewNoduleOnly = showNewNoduleOnlyCheckbox.checked;

                patientListBody.innerHTML = ''; // Clear previous list

                let allPatients = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('vdt-calc-')) {
                        const patientId = key.substring(9);
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data && data.tableData) {
                                const totals = calculateTotalVdtForPatientData(data);
                                allPatients.push({ id: patientId, ...data, totals });
                            }
                        } catch (e) {
                            console.error(`Could not parse data for patient ${patientId}:`, e);
                        }
                    }
                }

                const filteredPatients = allPatients.filter(p => {
                    const matchesSearch = p.id.toLowerCase().includes(searchTerm);
                    const matchesStar = !showStarredOnly || p.isStarred;
                    const matchesPositive = !showPositiveOnly || p.totals.isPositive;
                    const matchesNewNodule = !showNewNoduleOnly || p.isNewNodule;
                    return matchesSearch && matchesStar && matchesPositive && matchesNewNodule;
                });

                if (filteredPatients.length === 0) {
                    patientListBody.innerHTML = `<tr><td colspan="7">No patient records found.</td></tr>`;
                }

                filteredPatients.forEach(patient => {
                    const tr = document.createElement('tr');
                    tr.dataset.patientId = patient.id;
                    const starChar = patient.isStarred ? '★' : '☆';

                    tr.innerHTML = `
                        <td>
                            <button class="star-btn ${patient.isStarred ? 'starred' : ''}" title="Star this patient">${starChar}</button>
                        </td>
                        <td>${patient.id}</td>
                        <td>${patient.totals.solidVdtHtml}</td>
                        <td>${patient.totals.coreVdtHtml}</td>
                        <td>${patient.totals.ggoVdtHtml}</td>
                        <td>
                            <textarea class="notes-area">${patient.notes || ''}</textarea>
                        </td>
                        <td class="patient-actions">
                            <button class="control-btn add-row-btn load-patient-btn">Load</button>
                            <button class="control-btn remove-row-btn delete-patient-btn">Delete</button>
                        </td>
                    `;
                    patientListBody.appendChild(tr);
                });

                // Attach event listeners for the newly created elements
                patientListBody.querySelectorAll('tr').forEach(tr => {
                    const pId = tr.dataset.patientId;
                    if (!pId) return;

                    tr.querySelector('.star-btn').addEventListener('click', () => toggleStar(pId));
                    tr.querySelector('.notes-area').addEventListener('blur', (e) => saveNote(pId, e.target.value));
                    tr.querySelector('.load-patient-btn').addEventListener('click', () => loadPatientFromManager(pId));
                    tr.querySelector('.delete-patient-btn').addEventListener('click', () => deletePatient(pId));
                });


                patientManagerModal.classList.remove('hidden');
            }

            function calculateTotalVdtForPatientData(patientData) {
                const { tableData: pTableData, isNewNodule: pIsNewNodule } = patientData;
                const baseReturn = { solidVdtHtml: '-', coreVdtHtml: '-', ggoVdtHtml: '-', isPositive: false };
                if (!pTableData || pTableData.length < 2) return baseReturn;

                const dataForCalc = pTableData
                    .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) }))
                    .filter(d => d.dateObj)
                    .sort((a, b) => a.dateObj - b.dateObj);

                if (dataForCalc.length < 2) return baseReturn;

                const firstForTotal = (pIsNewNodule && dataForCalc.length > 1) ? dataForCalc[1] : dataForCalc[0];
                const last = dataForCalc[dataForCalc.length - 1];
                
                const totalTimeDiff = (last.dateObj - firstForTotal.dateObj) / (1000 * 60 * 60 * 24);

                const solidResult = calculateSingleVDT(last.solid, firstForTotal.solid, totalTimeDiff);
                const coreResult = calculateSingleVDT(last.core, firstForTotal.core, totalTimeDiff);
                const ggoResult = calculateSingleVDT(last.nonsolid, firstForTotal.nonsolid, totalTimeDiff);
                
                const formatVdtForManager = (result) => {
                    if (!result || !result.value) return { html: '-', numeric: null };
                    let display = result.value === 'Stable' ? 'Stable' : `${result.value}d`;
                    let styledHtml = display;
                    const vdtNum = parseFloat(result.value);

                    if (result.value && result.value !== 'Stable') {
                        if (vdtNum > 0 && vdtNum <= 400) {
                            styledHtml = `<strong style="color: #d9534f;">${display}</strong>`;
                        } else if (vdtNum > 400 && vdtNum <= 600) {
                            styledHtml = `<strong style="color: #f0ad4e;">${display}</strong>`;
                        }
                    }
                    return { html: styledHtml, numeric: vdtNum };
                }

                const styledSolid = formatVdtForManager(solidResult);
                const styledCore = formatVdtForManager(coreResult);
                const styledGgo = formatVdtForManager(ggoResult);

                const isPositive = (styledSolid.numeric > 0 && styledSolid.numeric <= 400) || 
                                   (styledCore.numeric > 0 && styledCore.numeric <= 400) ||
                                   (styledGgo.numeric > 0 && styledGgo.numeric <= 400);

                return {
                    solidVdtHtml: styledSolid.html,
                    coreVdtHtml: styledCore.html,
                    ggoVdtHtml: styledGgo.html,
                    isPositive: isPositive
                };
            }

            function loadPatientFromManager(patientId) {
                loadData(patientId);
                patientManagerModal.classList.add('hidden');
            }

            function deletePatient(patientId) {
                if (confirm(`Are you sure you want to delete all data for patient "${patientId}"? This action cannot be undone.`)) {
                    localStorage.removeItem(`vdt-calc-${patientId}`);
                    openPatientManager(); // Refresh the list
                }
            }

            function toggleStar(patientId) {
                const savedDataString = localStorage.getItem(`vdt-calc-${patientId}`);
                if (savedDataString) {
                    const data = JSON.parse(savedDataString);
                    data.isStarred = !data.isStarred;
                    localStorage.setItem(`vdt-calc-${patientId}`, JSON.stringify(data));
                    openPatientManager(); // Refresh the list to show the change
                }
            }

            function saveNote(patientId, noteText) {
                const savedDataString = localStorage.getItem(`vdt-calc-${patientId}`);
                if (savedDataString) {
                    const data = JSON.parse(savedDataString);
                    data.notes = noteText.trim();
                    localStorage.setItem(`vdt-calc-${patientId}`, JSON.stringify(data));
                    // No need to refresh the whole list, just to be efficient
                }
            }


            // --- Init & Event Listeners ---
            function initializeApp() {
                createTooltip(); // Create the tooltip div on init
                tableData = [];
                uniqueRowId = 0;
                for(let i = 0; i < 4; i++) { addScan(); }
            }
            
            // Register Chart.js plugins globally
            if (window.ChartDataLabels) Chart.register(ChartDataLabels);
            if (window.ChartAnnotation) Chart.register(window.ChartAnnotation);
            
            addScanBtn.addEventListener('click', addScan);
            clearBtn.addEventListener('click', clearAll);
            saveBtn.addEventListener('click', saveData);
            exportBtn.addEventListener('click', () => exportToCSV(true));
            exportNewBtn.addEventListener('click', saveAndNew);
            patientIdInput.addEventListener('blur', () => loadData());
            patientIdInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    loadData();
                }
            });
            sortOrderSelect.addEventListener('change', renderTable);
            newNoduleCheckbox.addEventListener('change', calculateAll);
            predictionCheckbox.addEventListener('change', calculateAll);
            logScaleCheckbox.addEventListener('change', calculateAll);

            // Tooltip event listener
            document.addEventListener('mouseover', function(event) {
                if (event.target.classList.contains('tooltip-icon')) {
                    const text = event.target.dataset.tooltip;
                    showTooltip(event.target, text);
                }
            });
            document.addEventListener('mouseout', function(event) {
                if (event.target.classList.contains('tooltip-icon')) {
                    hideTooltip();
                }
            });

            // Patient Manager Listeners
            managePatientsBtn.addEventListener('click', openPatientManager);
            modalCloseBtn.addEventListener('click', () => patientManagerModal.classList.add('hidden'));
            patientManagerModal.addEventListener('click', (e) => {
                if (e.target === patientManagerModal) { // Click on overlay
                    patientManagerModal.classList.add('hidden');
                }
            });
            patientSearchInput.addEventListener('input', openPatientManager);
            showStarredOnlyCheckbox.addEventListener('change', openPatientManager);
            showPositiveOnlyCheckbox.addEventListener('change', openPatientManager);
            showNewNoduleOnlyCheckbox.addEventListener('change', openPatientManager);
            
            initializeApp();
        };
    </script>
</body>
</html>

