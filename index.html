<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic VDT Calculator - Pro</title>
    <!-- Chart.js & Plugins -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Removed unused annotation plugin to prevent errors -->
    
    <style>
        :root {
            --primary-color: #007acc;
            --primary-hover: #005fa3;
            --secondary-color: #6c757d;
            --accent-green: #2e8b57;
            --accent-red: #e74c3c;
            --accent-blue: #3498db; /* For fast shrinking */
            --bg-color: #f4f6f8;
            --card-bg: #ffffff;
            --text-main: #2c3e50;
            --text-light: #7f8c8d;
            --border-color: #e1e4e8;
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
            --radius-md: 8px;
            --radius-sm: 4px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 30px;
            line-height: 1.5;
        }

        .container {
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            background-color: var(--card-bg);
            padding: 40px;
            border-radius: 12px;
            box-shadow: var(--shadow-md);
            position: relative;
        }

        /* --- Header --- */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin: 0;
            color: var(--text-main);
        }

        .version-tag {
            margin-left: 12px;
            font-size: 12px;
            font-weight: 500;
            color: var(--primary-color);
            background: rgba(0, 122, 204, 0.1);
            padding: 4px 8px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .version-tag:hover {
            background: rgba(0, 122, 204, 0.2);
        }

        .header-actions {
            display: flex;
            gap: 12px;
        }

        /* --- Patient ID Input --- */
        .patient-id-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 40px;
            background: #f8fafc;
            padding: 20px;
            border-radius: var(--radius-md);
            border: 1px dashed var(--border-color);
        }

        .patient-id-container label {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-main);
        }

        .patient-id-container input {
            padding: 10px 15px;
            border: 1px solid #d1d5db;
            border-radius: var(--radius-sm);
            font-size: 1.1em;
            width: 300px;
            outline: none;
            transition: border-color 0.2s;
        }
        .patient-id-container input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.1);
        }

        /* --- Controls & Buttons --- */
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .left-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            height: 36px;
            color: white;
            border: none;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }
        
        .control-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .control-btn:active {
            transform: translateY(0);
        }

        .add-row-btn { background-color: var(--accent-green); }
        .add-row-btn:hover { background-color: #257a4a; }
        
        .remove-row-btn { background-color: var(--accent-red); }
        .remove-row-btn:hover { background-color: #c0392b; }
        
        .manage-btn { background-color: var(--text-main); }
        .manage-btn:hover { background-color: #1a252f; }

        .clear-btn { background-color: #f39c12; }
        .clear-btn:hover { background-color: #e67e22; }

        .save-btn { background-color: var(--primary-color); }
        .save-btn:hover { background-color: var(--primary-hover); }
        
        .export-new-btn { background-color: #9b59b6; }
        .export-new-btn:hover { background-color: #8e44ad; }

        .export-btn { background-color: #16a085; }
        .export-btn:hover { background-color: #1abc9c; }

        .copy-btn { 
            background-color: #ffffff; 
            color: var(--text-main); 
            border: 1px solid #d1d5db;
            box-shadow: none;
            font-size: 0.85rem;
            height: 32px;
        }
        .copy-btn:hover {
            background-color: #f8f9fa;
            border-color: #9ca3af;
        }

        /* --- Options Groups --- */
        .sort-control, .new-nodule-control {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-main);
            background: #fff;
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
        }

        .sort-control select {
            border: none;
            background: transparent;
            font-weight: 500;
            color: var(--primary-color);
            cursor: pointer;
            outline: none;
        }

        /* --- Table --- */
        .data-table-wrapper {
            overflow-x: auto;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .data-table th {
            background-color: #f1f5f9;
            color: var(--text-main);
            font-weight: 600;
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .data-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            background-color: #fff;
        }

        .data-table tr:last-child td { border-bottom: none; }
        .data-table tr:hover td { background-color: #f8fafc; }

        .data-table input[type="text"], .data-table input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid transparent; /* Invisible border by default */
            border-radius: 4px;
            text-align: center;
            background: transparent;
            font-family: inherit;
        }
        .data-table input:hover {
            background: #fff;
            border-color: #e1e4e8;
        }
        .data-table input:focus {
            background: #fff;
            border-color: var(--primary-color);
            outline: none;
        }
        
        /* Radio button style */
        .baseline-radio {
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
        }

        /* Column widths */
        .row-controls { width: 40px; }
        .baseline-col { width: 40px; }
        .scan-number-col { width: 130px; font-weight: 600; color: var(--text-light); }

        /* Delete Controls */
        .delete-row-btn {
            background: none;
            border: none;
            color: #cbd5e1;
            cursor: pointer;
            font-size: 22px;
            font-weight: bold;
            transition: color 0.2s;
            line-height: 1;
        }
        .delete-row-btn:hover { color: var(--accent-red); }
        .data-table tr:hover .delete-row-btn { color: #ffadad; } /* Subtle red on row hover */
        .data-table tr:hover .delete-row-btn:hover { color: var(--accent-red); }

        /* --- Results Area --- */
        .total-results-container, .prediction-results-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .total-result-box, .prediction-result-box {
            background: #fff;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        
        .prediction-results-container .prediction-result-box {
            background-color: #fffcf5;
            border-color: #f1c40f;
        }

        .label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-light);
            font-weight: 600;
        }
        
        .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-main);
        }

        /* --- Chart --- */
        .chart-container {
            margin-top: 40px;
            padding: 20px;
            background: #fff;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            height: 600px;
        }

        /* --- Modals --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(2px);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .modal-overlay:not(.hidden) {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            width: 90%;
            max-width: 1200px;
            max-height: 85vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .patient-list-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .patient-list-controls input[type="search"] {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 300px;
            font-size: 1em;
        }

        .patient-list-table {
            width: 100%;
            border-collapse: collapse;
        }
        .patient-list-table th, .patient-list-table td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
            vertical-align: middle;
        }
        .patient-list-table th {
            background-color: #f8fafc;
            font-weight: 600;
        }
        
        .patient-actions {
            display: flex;
            gap: 8px;
        }
        .patient-actions button {
            font-size: 0.8rem;
            padding: 4px 12px;
            height: 28px;
        }

        .notes-area {
            width: 100%;
            min-height: 40px;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }

        .star-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #bdc3c7; /* Default empty star color */
            padding: 0;
        }
        .star-btn.starred {
            color: #f1c40f;
        }

        /* Utility */
        .hidden { display: none !important; }
        .vdt-positive { color: #d9534f; }
        .vdt-indeterminate { color: #f39c12; }
        .vdt-shrinking { color: #3498db; }
        
        /* Tooltip */
        .tooltip-icon {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            width: 16px; height: 16px;
            background: #e2e8f0;
            color: #64748b;
            border-radius: 50%;
            font-size: 10px;
            margin-left: 4px;
            cursor: help;
            vertical-align: text-top;
        }
        .tooltip-text {
            position: absolute;
            background: #334155;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            width: 250px;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .tooltip-text.visible { opacity: 1; }
        
        /* Changelog Styles */
        .changelog-list {
            list-style: none;
            padding: 0;
        }
        .changelog-item {
            margin-bottom: 20px;
            border-left: 3px solid #3498db;
            padding-left: 15px;
        }
        .changelog-version {
            font-weight: bold;
            font-size: 1.1em;
            color: #2c3e50;
        }
        .changelog-date {
            font-size: 0.8em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        .changelog-desc ul {
            margin: 5px 0 0 0;
            padding-left: 20px;
        }
        
        /* Scan label editable input style */
        .scan-label-input {
            font-weight: 600;
            color: #555;
        }
        .scan-label-input:focus {
            color: var(--primary-color);
        }

    </style>
</head>
<body>

    <div class="container">
        <div class="header-container">
            <h1>Dynamic VDT Calculator <span class="version-tag" id="version-log-btn">v2.7</span></h1>
            <div class="header-actions">
                <button class="control-btn manage-btn" id="manage-patients-btn">Worklist</button>
                <button class="control-btn export-btn" id="export-btn">Export CSV</button>
            </div>
        </div>
        
        <div class="patient-id-container">
            <label for="patient-id">Patient ID</label>
            <input type="text" id="patient-id" placeholder="Enter ID to Auto-Save/Load">
        </div>

        <div class="table-controls">
            <div class="left-controls">
                <button class="control-btn add-row-btn" id="add-scan-btn">Add Scan</button>
                
                <div class="sort-control">
                    <label for="sort-order">Sort:</label>
                    <select id="sort-order">
                        <option value="newest_first" selected>Newest First</option>
                        <option value="oldest_first">Oldest First</option>
                    </select>
                    <span class="tooltip-icon" data-tooltip="Display order only. Chronological calculation is automatic.">?</span>
                </div>

                <div class="new-nodule-control">
                    <input type="checkbox" id="new-nodule-checkbox">
                    <label for="new-nodule-checkbox">New Nodule (Max VDT)</label>
                    <span class="tooltip-icon" data-tooltip="For first-time nodules. Assumes 15mm³ pre-existence.">?</span>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="log-scale-checkbox">
                    <label for="log-scale-checkbox">Log Scale</label>
                    <span class="tooltip-icon" data-tooltip="Use logarithmic scale for Y-axis.">?</span>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="prediction-checkbox">
                    <label for="prediction-checkbox">Prediction</label>
                    <span class="tooltip-icon" data-tooltip="Show +3m and +1y volume projections on chart.">?</span>
                </div>
            </div>
            
            <div class="main-actions">
                <button class="control-btn clear-btn" id="clear-btn">Clear</button>
                <button class="control-btn save-btn" id="save-btn">Save</button>
                <button class="control-btn export-new-btn" id="export-new-btn">Save & New</button>
            </div>
        </div>

        <div class="data-table-wrapper">
            <table class="data-table" id="data-table">
                <thead>
                    <tr>
                        <th class="row-controls"></th>
                        <th class="baseline-col" title="Select Baseline">BL</th>
                        <th class="scan-number-col">Scan #</th>
                        <th>Date</th>
                        <th>Solid (mm³)</th>
                        <th>Core (mm³)</th>
                        <th>Non-solid (mm³)</th>
                        <th>VDT</th>
                        <th>VDT<sub>core</sub></th>
                        <th>VDT<sub>GGO</sub></th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Rows injected via JS -->
                </tbody>
            </table>
        </div>

        <div class="total-results-container" id="total-results-container">
            <!-- Totals injected via JS -->
        </div>

        <div class="prediction-results-container hidden" id="prediction-results-container">
            <!-- Predictions injected via JS -->
        </div>

        <div class="chart-container">
            <canvas id="volumeChart"></canvas>
        </div>
    </div>
    
    <!-- Patient Manager Modal -->
    <div id="patient-manager-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Patient Worklist</h2>
                <button id="modal-close-btn" class="modal-close-btn" style="font-size: 24px; background:none; border:none; cursor:pointer;">&times;</button>
            </div>
            <div class="patient-list-controls">
                <input type="search" id="patient-search-input" placeholder="Search Patient ID...">
                <div class="new-nodule-control">
                    <input type="checkbox" id="show-starred-only">
                    <label for="show-starred-only">Starred</label>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="show-positive-only">
                    <label for="show-positive-only">VDT Positive</label>
                </div>
                 <div class="new-nodule-control">
                    <input type="checkbox" id="show-new-nodule-only">
                    <label for="show-new-nodule-only">New Nodules</label>
                </div>
            </div>
            <div class="data-table-wrapper">
                <table class="patient-list-table data-table">
                    <thead>
                        <tr>
                            <th style="width: 50px;">Star</th>
                            <th>Patient ID</th>
                            <th>Total VDT</th>
                            <th>Total VDT<sub>core</sub></th>
                            <th>Total VDT<sub>GGO</sub></th>
                            <th style="width: 30%;">Notes</th>
                            <th style="width: 130px;">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="patient-list-body"></tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div id="changelog-modal" class="modal-overlay hidden">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>Update Log</h2>
                <button id="changelog-close-btn" class="modal-close-btn" style="font-size: 24px; background:none; border:none; cursor:pointer;">&times;</button>
            </div>
            <ul class="changelog-list">
                 <li class="changelog-item">
                    <div class="changelog-version">v2.7 - Bug Fixes & Optimization</div>
                    <div class="changelog-date">Current Version</div>
                    <div class="changelog-desc">
                        <ul>
                             <li><strong>Critical Fixes:</strong> Resolved chart crashing and copy report errors.</li>
                             <li><strong>Chart Labels:</strong> Added robust data labels showing Scan Name, Volume, and VDT directly on the chart.</li>
                             <li><strong>Copy Report:</strong> Optimized for dark mode presentation (Transparent BG, White Text) and added blue indicators for shrinking.</li>
                        </ul>
                    </div>
                </li>
                 <li class="changelog-item">
                    <div class="changelog-version">v2.6 - Reporting & Chart Upgrade</div>
                    <div class="changelog-desc">
                        <ul>
                            <li><strong>Dark Mode Ready Report:</strong> Copied reports now have transparent backgrounds and white text.</li>
                            <li><strong>New Risk Color:</strong> Added blue coding for "Fast Shrinking" VDTs.</li>
                        </ul>
                    </div>
                </li>
                 <li class="changelog-item">
                    <div class="changelog-version">v2.4.2 - Auto-Sorting & Simplified UI</div>
                    <div class="changelog-desc">
                        <ul>
                            <li><strong>Auto-Sorting:</strong> Table automatically sorts by date in real-time.</li>
                        </ul>
                    </div>
                </li>
            </ul>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Global variables ---
            const tableBody = document.getElementById('table-body');
            const addScanBtn = document.getElementById('add-scan-btn');
            const clearBtn = document.getElementById('clear-btn');
            const saveBtn = document.getElementById('save-btn');
            const exportBtn = document.getElementById('export-btn');
            const exportNewBtn = document.getElementById('export-new-btn');
            const patientIdInput = document.getElementById('patient-id');
            const totalResultsContainer = document.getElementById('total-results-container');
            const predictionResultsContainer = document.getElementById('prediction-results-container');
            const sortOrderSelect = document.getElementById('sort-order');
            const newNoduleCheckbox = document.getElementById('new-nodule-checkbox');
            const logScaleCheckbox = document.getElementById('log-scale-checkbox');
            const predictionCheckbox = document.getElementById('prediction-checkbox');
            const chartCanvas = document.getElementById('volumeChart');
            const container = document.querySelector('.container');
            
            // Modal elements
            const managePatientsBtn = document.getElementById('manage-patients-btn');
            const patientManagerModal = document.getElementById('patient-manager-modal');
            const modalCloseBtn = document.getElementById('modal-close-btn');
            const patientListBody = document.getElementById('patient-list-body');
            const patientSearchInput = document.getElementById('patient-search-input');
            const showStarredOnlyCheckbox = document.getElementById('show-starred-only');
            const showPositiveOnlyCheckbox = document.getElementById('show-positive-only');
            const showNewNoduleOnlyCheckbox = document.getElementById('show-new-nodule-only');

            const versionLogBtn = document.getElementById('version-log-btn');
            const changelogModal = document.getElementById('changelog-modal');
            const changelogCloseBtn = document.getElementById('changelog-close-btn');

            let tooltipDiv = null;
            
            let uniqueRowId = 0;
            let tableData = [];
            let volumeChart = null;

            // --- UI Helpers ---
            function createTooltip() {
                if (!tooltipDiv) {
                    tooltipDiv = document.createElement('div');
                    tooltipDiv.className = 'tooltip-text';
                    document.body.appendChild(tooltipDiv); 
                }
            }

            function showTooltip(target, text) {
                if (!tooltipDiv) createTooltip();
                tooltipDiv.innerHTML = text;
                tooltipDiv.classList.add('visible');
                
                const rect = target.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                let top = rect.top + scrollTop - tooltipDiv.offsetHeight - 10;
                let left = rect.left + (rect.width / 2) - (tooltipDiv.offsetWidth / 2);

                tooltipDiv.style.top = `${Math.max(10, top)}px`;
                tooltipDiv.style.left = `${Math.max(10, left)}px`;
            }

            function hideTooltip() {
                if (tooltipDiv) tooltipDiv.classList.remove('visible');
            }

            // --- Core Logic ---
            function renderTable() {
                const sortOrder = sortOrderSelect.value;
                // Clone for visual sorting only
                const sortedData = [...tableData].sort((a, b) => {
                    const dateA = parseDateString(a.date) || 0;
                    const dateB = parseDateString(b.date) || 0;
                    if (sortOrder === 'newest_first') return dateB - dateA;
                    return dateA - dateB;
                });

                tableBody.innerHTML = '';
                sortedData.forEach(dataRow => {
                    const tr = document.createElement('tr');
                    tr.dataset.id = dataRow.id;
                    tr.innerHTML = `
                        <td class="row-controls">
                            <button class="delete-row-btn" title="Delete">&times;</button>
                        </td>
                        <td>
                            <input type="radio" name="baseline-group" class="baseline-radio" ${dataRow.isBaseline ? 'checked' : ''}>
                        </td>
                        <td class="scan-number scan-number-col">
                             <input type="text" class="scan-label-input" value="${dataRow.customLabel || ''}" placeholder="-">
                        </td>
                        <td><input type="text" class="date-input" value="${dataRow.date}" placeholder="YYYY-MM-DD"></td>
                        <td><input type="number" class="solid-input" value="${dataRow.solid}" min="0" step="0.1"></td>
                        <td><input type="number" class="core-input" value="${dataRow.core}" min="0" step="0.1"></td>
                        <td><input type="number" class="nonsolid-input" value="${dataRow.nonsolid || ''}" min="0" step="0.1"></td>
                        <td class="result-cell vdt-solid-result">-</td>
                        <td class="result-cell vdt-core-result">-</td>
                        <td class="result-cell vdt-ggo-result">-</td>
                    `;
                    tableBody.appendChild(tr);
                });
                
                bindEventListeners();
                updateScanLabels(); 
                calculateAll();
            }

            function getScanLabel(months) {
                if (months <= 0.5) return "Baseline";
                if (months < 10.5) {
                    if (months >= 1.5 && months < 4.5) return "Baseline+3m";
                    if (months >= 4.5 && months < 7.5) return "Baseline+6m";
                    if (months >= 7.5 && months < 10.5) return "Baseline+9m";
                }
                const years = Math.round(months / 12);
                const remainder = Math.abs(months - (years * 12));
                let baseLabel = "";
                if (years === 1) baseLabel = "1st Annual";
                else if (years === 2) baseLabel = "2nd Annual";
                else baseLabel = `${years}th Annual`;
                if (remainder <= 1.5) return baseLabel;
                const rawYears = Math.floor(months / 12);
                const extra = months - (rawYears * 12);
                if (rawYears === 1) baseLabel = "1st Annual";
                else if (rawYears === 2) baseLabel = "2nd Annual";
                else baseLabel = `${rawYears}th Annual`;
                if (extra >= 1.5 && extra < 4.5) return `${baseLabel}+3m`;
                if (extra >= 4.5 && extra < 7.5) return `${baseLabel}+6m`;
                if (extra >= 7.5 && extra < 10.5) return `${baseLabel}+9m`;
                return baseLabel;
            }

            function updateScanLabels() {
                const chronoData = [...tableData]
                    .map(d => ({...d, dateObj: parseDateString(d.date)}))
                    .filter(d => d.dateObj)
                    .sort((a, b) => b.dateObj - a.dateObj);
                const baselineRow = chronoData.find(d => d.isBaseline);
                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const rowId = parseInt(row.dataset.id);
                    const dataRow = tableData.find(d => d.id === rowId);
                    const input = row.querySelector('.scan-label-input');
                    let generatedLabel = '-';
                    if (dataRow && dataRow.date) { 
                        const currentScan = chronoData.find(d => d.id === rowId);
                         if (currentScan) {
                             if (baselineRow) {
                                if (currentScan.id === baselineRow.id) {
                                     generatedLabel = "Baseline";
                                 } else {
                                     const diffTime = currentScan.dateObj - baselineRow.dateObj;
                                     if (diffTime < 0) {
                                          const months = Math.round(Math.abs(diffTime) / (1000 * 60 * 60 * 24 * 30.44));
                                          generatedLabel = `Pre-BL(${months}m)`;
                                     } else {
                                          const months = Math.round(diffTime / (1000 * 60 * 60 * 24 * 30.44));
                                          generatedLabel = getScanLabel(months);
                                     }
                                 }
                             } else {
                                 const chronoIndex = chronoData.findIndex(d => d.id === rowId);
                                 generatedLabel = chronoIndex === 0 ? 'Scan 0' : `Scan -${chronoIndex}`;
                             }
                         }
                    }
                    if (document.activeElement !== input) {
                         dataRow.customLabel = generatedLabel; 
                         input.value = generatedLabel;
                    }
                });
            }

            function addScan() {
                tableData.push({ id: uniqueRowId++, date: '', solid: '', core: '', nonsolid: '', isBaseline: false, customLabel: '' });
                renderTable();
            }

            function deleteRow(rowId) {
                if (tableData.length > 0) {
                    tableData = tableData.filter(d => d.id !== rowId);
                    renderTable();
                }
            }

            function setBaseline(rowId) {
                tableData.forEach(d => {
                    d.isBaseline = (d.id === rowId);
                });
                renderTable(); 
            }

            function clearAll() {
                patientIdInput.value = '';
                tableData = [];
                newNoduleCheckbox.checked = false;
                logScaleCheckbox.checked = false;
                predictionCheckbox.checked = false;
                uniqueRowId = 0;
                for(let i=0; i<4; i++) addScan();
            }

            // --- Data & Events ---
            function bindEventListeners() {
                tableBody.querySelectorAll('tr').forEach(tr => {
                    const rowId = parseInt(tr.dataset.id);
                    const dataRow = tableData.find(d => d.id === rowId);
                    
                    const dateInput = tr.querySelector('.date-input');
                    dateInput.addEventListener('input', (e) => updateData(e, 'date', false));
                    dateInput.addEventListener('change', (e) => {
                        format_date(e);
                        updateData(e, 'date', true); 
                    });

                    tr.querySelector('.solid-input').addEventListener('input', (e) => updateData(e, 'solid'));
                    tr.querySelector('.core-input').addEventListener('input', (e) => updateData(e, 'core'));
                    tr.querySelector('.nonsolid-input').addEventListener('input', (e) => updateData(e, 'nonsolid'));
                    tr.querySelector('.delete-row-btn').addEventListener('click', () => deleteRow(rowId));
                    
                    const radio = tr.querySelector('.baseline-radio');
                    radio.addEventListener('click', (e) => {
                        if (dataRow.isBaseline) {
                            e.preventDefault();
                            dataRow.isBaseline = false;
                            setTimeout(() => renderTable(), 0);
                        } else {
                            setBaseline(rowId);
                        }
                    });
                    
                    const labelInput = tr.querySelector('.scan-label-input');
                    labelInput.addEventListener('input', (e) => {
                         dataRow.customLabel = e.target.value;
                    });

                    tr.querySelectorAll('input').forEach(inp => inp.addEventListener('paste', handlePaste));
                });
            }

            function updateData(event, key, forceRender = true) {
                const rowId = parseInt(event.target.closest('tr').dataset.id);
                const dataRow = tableData.find(d => d.id === rowId);
                if (dataRow) dataRow[key] = event.target.value;
                
                if (key === 'date' && !forceRender) {
                     calculateAll(); 
                } else {
                     if(forceRender) renderTable();
                     else calculateAll();
                }
            }

            function format_date(event) {
                 let value = event.target.value.replace(/-/g, '');
                if (value.length === 8 && !isNaN(value)) {
                    event.target.value = `${value.substring(0, 4)}-${value.substring(4, 6)}-${value.substring(6, 8)}`;
                }
            }
            
            function parseDateString(dateStr) {
                if (!dateStr) return null;
                const cleanStr = dateStr.replace(/-/g, '');
                if (cleanStr.length !== 8 || isNaN(cleanStr)) return null;
                return new Date(parseInt(cleanStr.substring(0, 4)), parseInt(cleanStr.substring(4, 6)) - 1, parseInt(cleanStr.substring(6, 8)));
            }

            function handlePaste(event) { }

            // --- Calculation & Rendering ---
            function calculateSingleVDT(vol1, vol2, timeDiff, isNewNoduleCalc = false) {
                const base = { html: '-', value: null, timeDiff: null, volumeChange: null };
                if (!timeDiff || timeDiff <= 0 || isNaN(vol1) || isNaN(vol2) || vol1 <= 0 || vol2 <= 0) return base;

                // NEW: Check for New Nodule shrinking threshold (vol1 = current, vol2 = assumed 15)
                if (isNewNoduleCalc && vol1 < vol2) {
                    return { html: 'N/A (<15mm³)', value: null, timeDiff: null, volumeChange: null };
                }
                
                const volumeChange = ((vol1 - vol2) / vol2) * 100;
                if (vol1 === vol2) return { html: '<span class="vdt-stable-or-slow">Stable</span>', value: 'Stable', timeDiff: timeDiff.toFixed(0), volumeChange: '0.0' };
                
                const vdt = (Math.log(2) * timeDiff) / (Math.log(vol1) - Math.log(vol2));
                const disp = vdt.toFixed(0);
                let cls = 'vdt-stable-or-slow';
                // NEW: Color coding logic including fast shrinking
                if (vdt > 0 && vdt <= 400) cls = 'vdt-positive';
                else if (vdt > 400 && vdt <= 600) cls = 'vdt-indeterminate';
                else if (vdt < 0 && vdt >= -400) cls = 'vdt-shrinking';
                
                return { html: `<strong><span class="${cls}">${disp}d</span></strong>`, value: disp, timeDiff: timeDiff.toFixed(0), volumeChange: volumeChange.toFixed(1) };
            }

            function calculateAll() {
                const isNewNodule = newNoduleCheckbox.checked;
                const dataForCalc = tableData
                    .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) }))
                    .filter(d => d.dateObj)
                    .sort((a, b) => a.dateObj - b.dateObj);

                document.querySelectorAll('.result-cell').forEach(c => c.innerHTML = '-');
                totalResultsContainer.innerHTML = '';
                predictionResultsContainer.classList.add('hidden');

                let firstSolid, firstCore, firstGgo; 
                
                for (let i = 1; i < dataForCalc.length; i++) {
                    const prev = dataForCalc[i - 1];
                    const curr = dataForCalc[i];
                    const isFirst = (i === 1);
                    const isMaxCalc = (isFirst && isNewNodule);

                    const prevSolid = isMaxCalc ? 15 : prev.solid;
                    const prevCore = isMaxCalc ? 15 : prev.core;
                    const prevGgo = isMaxCalc ? 15 : prev.nonsolid;
                    
                    const tDiff = (curr.dateObj - prev.dateObj) / (86400000); 
                    
                    const resS = calculateSingleVDT(curr.solid, prevSolid, tDiff, isMaxCalc);
                    const resC = calculateSingleVDT(curr.core, prevCore, tDiff, isMaxCalc);
                    const resG = calculateSingleVDT(curr.nonsolid, prevGgo, tDiff, isMaxCalc);

                    if (isFirst) { firstSolid = resS; firstCore = resC; firstGgo = resG; }

                    const row = Array.from(tableBody.querySelectorAll('tr')).find(r => parseInt(r.dataset.id) === curr.id);
                    if (row) {
                        // Helper to append (max) label
                        const fmt = (r) => {
                            if (!r.value && r.html.includes('N/A')) return r.html;
                            if (!r.value) return '-';
                            let html = r.html;
                            if (isMaxCalc) html += '<sub>(max)</sub>';
                            html += `<div class="extra-info">${r.timeDiff}d | ${r.volumeChange > 0 ? '+' : ''}${r.volumeChange}%</div>`;
                            return html;
                        };
                        row.querySelector('.vdt-solid-result').innerHTML = fmt(resS);
                        row.querySelector('.vdt-core-result').innerHTML = fmt(resC);
                        row.querySelector('.vdt-ggo-result').innerHTML = fmt(resG);
                    }
                    
                    curr.vdtSolid = resS.value;
                    curr.vdtCore = resC.value;
                    curr.vdtNonsolid = resG.value;
                }

                let totalS, totalC, totalG;
                if (dataForCalc.length > 1) {
                    const start = (isNewNodule && dataForCalc.length > 1) ? dataForCalc[1] : dataForCalc[0];
                    const end = dataForCalc[dataForCalc.length - 1];
                    const tDiff = (end.dateObj - start.dateObj) / 86400000;
                    
                    totalS = calculateSingleVDT(end.solid, start.solid, tDiff);
                    totalC = calculateSingleVDT(end.core, start.core, tDiff);
                    totalG = calculateSingleVDT(end.nonsolid, start.nonsolid, tDiff);

                    const boxHtml = (label, res, type) => `
                        <div class="total-result-box">
                            <div class="label">${label}</div>
                            <div class="value">${res.value ? (res.value === 'Stable' ? 'Stable' : res.value + 'd') : '-'}</div>
                            <button class="control-btn copy-btn" onclick="copyReport('${type}', this)">Copy Report</button>
                        </div>`;

                    totalResultsContainer.innerHTML = 
                        boxHtml('Total VDT', totalS, 'solid') + 
                        boxHtml('Total VDT<sub>core</sub>', totalC, 'core') + 
                        boxHtml('Total VDT<sub>GGO</sub>', totalG, 'nonsolid');
                }

                if (predictionCheckbox.checked && dataForCalc.length > 0) {
                    predictionResultsContainer.classList.remove('hidden');
                    const last = dataForCalc[dataForCalc.length - 1];
                    
                    let vdtS = (isNewNodule && dataForCalc.length === 2) ? firstSolid : totalS;
                    let vdtC = (isNewNodule && dataForCalc.length === 2) ? firstCore : totalC;
                    let vdtG = (isNewNodule && dataForCalc.length === 2) ? firstGgo : totalG;

                    const calcPred = (vdtRes, startVol) => {
                        if (!vdtRes || !vdtRes.value || vdtRes.value === 'Stable' || parseFloat(vdtRes.value) <= 0) return { m3: 'N/A', y1: 'N/A' };
                        const v = parseFloat(vdtRes.value);
                        return { 
                            m3: (startVol * Math.pow(2, 90/v)).toFixed(1), 
                            y1: (startVol * Math.pow(2, 365/v)).toFixed(1) 
                        };
                    };

                    const predS = calcPred(vdtS, last.solid);
                    const predC = calcPred(vdtC, last.core);
                    const predG = calcPred(vdtG, last.nonsolid);

                    const pBox = (label, p) => `
                        <div class="prediction-result-box">
                            <div class="label">${label} (3m / 1yr)</div>
                            <div class="value">${p.m3} / ${p.y1} mm³</div>
                        </div>`;
                    
                    predictionResultsContainer.innerHTML = 
                        pBox('Solid', predS) + pBox('Core', predC) + pBox('Non-solid', predG);
                }

                renderChart(dataForCalc, totalS, totalC, totalG);
            }

            function renderChart(data, totS, totC, totG) {
                if (volumeChart) volumeChart.destroy();
                const ctx = chartCanvas.getContext('2d');
                
                let chartData = data.map(d => ({...d}));
                const isNewNodule = newNoduleCheckbox.checked;
                const useLog = logScaleCheckbox.checked;

                if (isNewNodule && chartData.length > 0) {
                    chartData[0].solid = 15; chartData[0].core = 15; chartData[0].nonsolid = 15;
                }

                const validData = chartData.filter(d => !isNaN(d.solid) || !isNaN(d.core) || !isNaN(d.nonsolid));
                if (validData.length < 1) return;
                
                // Calculate dates for prediction
                const last = validData[validData.length-1];
                const date3m = new Date(last.dateObj); date3m.setDate(date3m.getDate() + 90);
                const date1y = new Date(last.dateObj); date1y.setDate(date1y.getDate() + 365);

                const createDs = (label, color, key, vdtKey) => ({
                    label: label,
                    data: chartData.map(d => ({
                        x: d.dateObj, 
                        y: d[key],
                        vdt: d[vdtKey], 
                        label: d.customLabel || 'Scan'
                    })).filter(p => !isNaN(p.y)),
                    borderColor: color,
                    backgroundColor: color,
                    tension: 0.1,
                    datalabels: {
                        align: 'top',
                        color: '#333',
                        font: { weight: 'bold', size: 11 },
                        // NEW: Background box for labels
                        backgroundColor: 'rgba(255,255,255,0.8)',
                        borderRadius: 4,
                        padding: 4,
                        offset: 4,
                        formatter: (v, ctx) => {
                            const point = ctx.dataset.data[ctx.dataIndex];
                            let str = point.label;
                            str += `\n${v.y.toFixed(1)} mm³`;
                            // NEW: Show VDT directly on node if available
                            if (point.vdt && point.vdt !== 'Stable' && point.vdt !== '-') {
                                str += `\nVDT: ${point.vdt}d`;
                            }
                            return str;
                        }
                    }
                });

                const datasets = [
                    createDs('Solid', '#3498db', 'solid', 'vdtSolid'),
                    createDs('Core', '#e74c3c', 'core', 'vdtCore'),
                    createDs('Non-solid', '#2ecc71', 'nonsolid', 'vdtNonsolid')
                ];

                if (predictionCheckbox.checked && validData.length > 0) {
                    const addPredLine = (label, color, startVol, vdtRes) => {
                         if(!vdtRes || !vdtRes.value || vdtRes.value === 'Stable' || parseFloat(vdtRes.value) <= 0) return;
                         const v = parseFloat(vdtRes.value);
                         const p3 = startVol * Math.pow(2, 90/v);
                         const p1 = startVol * Math.pow(2, 365/v);
                         
                         datasets.push({
                             label: label + ' Pred',
                             data: [{x: last.dateObj, y: startVol}, {x: date3m, y: p3}, {x: date1y, y: p1}],
                             borderColor: color,
                             borderDash: [5, 5],
                             pointRadius: 4,
                             pointBackgroundColor: 'white',
                             datalabels: {
                                 align: 'right',
                                 color: color,
                                 backgroundColor: 'rgba(255,255,255,0.8)',
                                 borderRadius: 4,
                                 padding: 4,
                                 formatter: (v, ctx) => {
                                     if(ctx.dataIndex === 0) return null;
                                     const lbl = ctx.dataIndex === 1 ? '+3m' : '+1y';
                                     return `${lbl}\n${v.y.toFixed(1)} mm³`;
                                 }
                             }
                         });
                    };

                    addPredLine('Solid', '#3498db', last.solid, totS);
                    addPredLine('Core', '#e74c3c', last.core, totC);
                    addPredLine('Non-solid', '#2ecc71', last.nonsolid, totG);
                }

                // Force plugin registration locally for chart instance just in case
                volumeChart = new Chart(ctx, {
                    type: 'line',
                    // FIX: Register DataLabels globally for stability
                    plugins: [ChartDataLabels],
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                             padding: { top: 30, left: 10, right: 20, bottom: 0 }
                        },
                        scales: {
                            x: { 
                                type: 'time', 
                                time: { 
                                    unit: 'day',
                                    tooltipFormat: 'yyyy-MM-dd' 
                                },
                                ticks: {
                                    source: 'data', // Only show ticks for data points
                                    autoSkip: false,
                                    maxRotation: 45,
                                    minRotation: 45
                                },
                                title: { display: true, text: 'Date' }
                            },
                            y: { 
                                type: useLog ? 'logarithmic' : 'linear',
                                title: { display: true, text: 'Volume (mm³)' }
                            }
                        },
                        plugins: {
                            // Force display true
                            datalabels: { display: true },
                            tooltip: { enabled: false }, 
                            legend: { position: 'bottom' }
                        }
                    }
                });
            }
            
            window.copyReport = function(type, btn) {
                const dataForCalc = tableData
                    .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) }))
                    .filter(d => d.dateObj).sort((a, b) => b.dateObj - a.dateObj); 

                if (dataForCalc.length < 1) return;
                
                const numCols = dataForCalc.length > 1 ? dataForCalc.length * 2 - 1 : 1;
                // NEW: Background transparent, Font Color White
                const cellStyle = "border: none; padding: 0.01in; text-align: center; font-family: Arial; font-size: 11pt; color: white; background-color: transparent;";
                const tableStyle = `font-family: Arial; font-size: 11pt; border-collapse: collapse; border: none; background-color: transparent; table-layout: fixed; width: ${numCols * 100}px;`;
                
                let html = `<table style="${tableStyle}">`;
                
                const first = dataForCalc[dataForCalc.length-1];
                const last = dataForCalc[0];
                const diff = (last.dateObj - first.dateObj) / 86400000;
                
                let v1, v2, lbl;
                if(type==='solid') { v1=last.solid; v2=first.solid; lbl='Total VDT'; }
                else if(type==='core') { v1=last.core; v2=first.core; lbl='Total VDT<sub>core</sub>'; }
                else { v1=last.nonsolid; v2=first.nonsolid; lbl='Total VDT<sub>GGO</sub>'; }
                
                const res = calculateSingleVDT(v1, v2, diff);
                
                let disp = res.value ? res.value + 'd' : 'N/A';
                if(res.value === 'Stable') disp = 'Stable';
                // NEW: Blue color coding for fast shrinking
                else if(parseFloat(res.value) > 0 && parseFloat(res.value) <= 400) disp = `<b style="color:red">${disp}</b>`;
                else if(parseFloat(res.value) > 400 && parseFloat(res.value) <= 600) disp = `<b style="color:orange">${disp}</b>`;
                else if(parseFloat(res.value) < 0 && parseFloat(res.value) >= -400) disp = `<b style="color:#3498db">${disp}</b>`;
                else disp = `<b>${disp}</b>`;
                
                html += `<tr><td colspan="${numCols}" style="${cellStyle}">${lbl}: ${disp}</td></tr>`;
                
                // Scans Row
                html += '<tr>';
                dataForCalc.forEach((s, i) => {
                    const num = s.customLabel || `Scan ${dataForCalc.length - 1 - i}`;
                    html += `<td style="${cellStyle}">${num}</td>`;
                    if(i < dataForCalc.length -1) html += `<td style="${cellStyle}"></td>`;
                });
                html += '</tr>';
                
                // Volumes Row
                html += '<tr>';
                dataForCalc.forEach((s, i) => {
                    let v = type==='solid' ? s.solid : (type==='core' ? s.core : s.nonsolid);
                    if(i === dataForCalc.length - 1 && document.getElementById('new-nodule-checkbox').checked) v = 15;
                    html += `<td style="${cellStyle}">${isNaN(v)?'N/A':v.toFixed(0)+' mm³'}</td>`;
                    if(i < dataForCalc.length -1) html += `<td style="${cellStyle}"></td>`;
                });
                html += '</tr>';
                
                // VDT Row
                html += '<tr>';
                for(let i=0; i<dataForCalc.length; i++) {
                    if(i === dataForCalc.length -1) {
                         html += `<td style="${cellStyle}"></td>`;
                    } else {
                         html += `<td style="${cellStyle}"></td>`; 
                         const curr = dataForCalc[i]; const prev = dataForCalc[i+1];
                         const d = (curr.dateObj - prev.dateObj)/86400000;
                         let vc = type==='solid' ? curr.solid : (type==='core'?curr.core:curr.nonsolid);
                         let vp = type==='solid' ? prev.solid : (type==='core'?prev.core:prev.nonsolid);
                         
                         let isMax = (i+1 === dataForCalc.length -1 && document.getElementById('new-nodule-checkbox').checked);
                         if(isMax) vp = 15;
                         
                         const r = calculateSingleVDT(vc, vp, d, isMax);
                         
                         let dStr = r.value ? r.value + 'd' : 'N/A';
                         if(r.html && r.html.includes('<15mm')) dStr = 'N/A'; // Handle the small new nodule case
                         else if(r.value === 'Stable') dStr = 'Stable';
                         // NEW: Blue color coding here too
                         else if(parseFloat(r.value) > 0 && parseFloat(r.value) <= 400) dStr = `<b style="color:red">${dStr}</b>`;
                         else if(parseFloat(r.value) > 400 && parseFloat(r.value) <= 600) dStr = `<b style="color:orange">${dStr}</b>`;
                         else if(parseFloat(r.value) < 0 && parseFloat(r.value) >= -400) dStr = `<b style="color:#3498db">${dStr}</b>`;
                         
                         let l = type==='solid' ? 'VDT' : (type==='core'?'VDT<sub>core</sub>':'VDT<sub>GGO</sub>');
                         if(isMax) l += '<sub>(max)</sub>';
                         
                         html += `<td style="${cellStyle}">${l}: ${dStr}</td>`;
                    }
                }
                html += '</tr></table>';
                
                const t = document.createElement('div');
                t.innerHTML = html;
                t.style.position='absolute'; t.style.left='-9999px';
                document.body.appendChild(t);
                const range = document.createRange();
                range.selectNode(t);
                window.getSelection().removeAllRanges();
                window.getSelection().addRange(range);
                document.execCommand('copy');
                document.body.removeChild(t);
                
                const orig = btn.textContent;
                btn.textContent = 'Copied!';
                btn.style.background = '#27ae60';
                btn.style.color = 'white';
                setTimeout(() => {
                    btn.textContent = orig;
                    btn.style.background = '';
                    btn.style.color = '';
                }, 1500);
            };

            // ... (Keep Patient Manager logic unchanged) ...
             function openPatientManager() {
                 const searchTerm = patientSearchInput.value.toLowerCase();
                const showStarredOnly = showStarredOnlyCheckbox.checked;
                const showPositiveOnly = showPositiveOnlyCheckbox.checked;
                const showNewNoduleOnly = showNewNoduleOnlyCheckbox.checked;

                patientListBody.innerHTML = '';
                let allPatients = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('vdt-calc-')) {
                        const patientId = key.substring(9);
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data && data.tableData) {
                                const totals = calculateTotalVdtForPatientData(data);
                                allPatients.push({ id: patientId, ...data, totals });
                            }
                        } catch (e) {}
                    }
                }
                const filteredPatients = allPatients.filter(p => {
                    const matchesSearch = p.id.toLowerCase().includes(searchTerm);
                    const matchesStar = !showStarredOnly || p.isStarred;
                    const matchesPositive = !showPositiveOnly || p.totals.isPositive;
                    const matchesNewNodule = !showNewNoduleOnly || p.isNewNodule;
                    return matchesSearch && matchesStar && matchesPositive && matchesNewNodule;
                });

                if (filteredPatients.length === 0) {
                    patientListBody.innerHTML = `<tr><td colspan="7">No patient records found.</td></tr>`;
                }
                filteredPatients.forEach(patient => {
                    const tr = document.createElement('tr');
                    const starChar = patient.isStarred ? '★' : '☆';
                    tr.innerHTML = `
                        <td><button class="star-btn ${patient.isStarred ? 'starred' : ''}" onclick="toggleStar('${patient.id}')">${starChar}</button></td>
                        <td>${patient.id}</td>
                        <td>${patient.totals.solidVdtHtml}</td>
                        <td>${patient.totals.coreVdtHtml}</td>
                        <td>${patient.totals.ggoVdtHtml}</td>
                        <td><textarea class="notes-area" onblur="saveNote('${patient.id}', this.value)">${patient.notes || ''}</textarea></td>
                        <td class="patient-actions">
                            <button class="control-btn add-row-btn" onclick="loadFromManager('${patient.id}')">Load</button>
                            <button class="control-btn remove-row-btn" onclick="deletePatient('${patient.id}')">Del</button>
                        </td>
                    `;
                    patientListBody.appendChild(tr);
                });
                patientManagerModal.classList.remove('hidden');
            }

            // ... (Helper functions: calculateTotalVdtForPatientData, toggleStar, saveNote, etc.)
             function calculateTotalVdtForPatientData(patientData) {
                const { tableData: pTableData, isNewNodule: pIsNewNodule } = patientData;
                const baseReturn = { solidVdtHtml: '-', coreVdtHtml: '-', ggoVdtHtml: '-', isPositive: false };
                if (!pTableData || pTableData.length < 2) return baseReturn;
                const dataForCalc = pTableData.map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core), nonsolid: parseFloat(d.nonsolid) })).filter(d => d.dateObj).sort((a, b) => a.dateObj - b.dateObj);
                if (dataForCalc.length < 2) return baseReturn;
                const firstForTotal = (pIsNewNodule && dataForCalc.length > 1) ? dataForCalc[1] : dataForCalc[0];
                const last = dataForCalc[dataForCalc.length - 1];
                const totalTimeDiff = (last.dateObj - firstForTotal.dateObj) / (1000 * 60 * 60 * 24);
                const solidResult = calculateSingleVDT(last.solid, firstForTotal.solid, totalTimeDiff);
                const coreResult = calculateSingleVDT(last.core, firstForTotal.core, totalTimeDiff);
                const ggoResult = calculateSingleVDT(last.nonsolid, firstForTotal.nonsolid, totalTimeDiff);
                const formatVdtForManager = (result) => {
                    if (!result || !result.value) return { html: '-', numeric: null };
                    let display = result.value === 'Stable' ? 'Stable' : `${result.value}d`;
                    let styledHtml = display;
                    const vdtNum = parseFloat(result.value);
                    if (result.value && result.value !== 'Stable') {
                        if (vdtNum > 0 && vdtNum <= 400) styledHtml = `<strong style="color: #d9534f;">${display}</strong>`;
                        else if (vdtNum > 400 && vdtNum <= 600) styledHtml = `<strong style="color: #f0ad4e;">${display}</strong>`;
                    }
                    return { html: styledHtml, numeric: vdtNum };
                }
                const styledSolid = formatVdtForManager(solidResult);
                const styledCore = formatVdtForManager(coreResult);
                const styledGgo = formatVdtForManager(ggoResult);
                const isPositive = (styledSolid.numeric > 0 && styledSolid.numeric <= 400) || (styledCore.numeric > 0 && styledCore.numeric <= 400) || (styledGgo.numeric > 0 && styledGgo.numeric <= 400);
                return { solidVdtHtml: styledSolid.html, coreVdtHtml: styledCore.html, ggoVdtHtml: styledGgo.html, isPositive: isPositive };
            }
            window.toggleStar = function(pid) { const str=localStorage.getItem(`vdt-calc-${pid}`); if(str){ const d=JSON.parse(str); d.isStarred=!d.isStarred; localStorage.setItem(`vdt-calc-${pid}`, JSON.stringify(d)); openPatientManager(); }};
            window.saveNote = function(pid, txt) { const str=localStorage.getItem(`vdt-calc-${pid}`); if(str){ const d=JSON.parse(str); d.notes=txt; localStorage.setItem(`vdt-calc-${pid}`, JSON.stringify(d)); }};
            window.loadFromManager = function(pid) { loadData(pid); patientManagerModal.classList.add('hidden'); };
            window.deletePatient = function(pid) { if(confirm('Delete?')){ localStorage.removeItem(`vdt-calc-${pid}`); openPatientManager(); }};

            function saveData() {
                const pid = patientIdInput.value.trim();
                if (!pid) { alert('Please enter a Patient ID.'); return; }
                let existing = {};
                const str = localStorage.getItem(`vdt-calc-${pid}`);
                if(str) existing = JSON.parse(str);
                const data = { ...existing, tableData: tableData, isNewNodule: newNoduleCheckbox.checked, isLogScale: logScaleCheckbox.checked, isPrediction: predictionCheckbox.checked, isNewNoduleFilter: showNewNoduleOnlyCheckbox.checked };
                localStorage.setItem(`vdt-calc-${pid}`, JSON.stringify(data));
                const orig = saveBtn.textContent; saveBtn.textContent = 'Saved!'; setTimeout(() => saveBtn.textContent = orig, 2000);
            }
            function loadData(pid) {
                const id = pid || patientIdInput.value.trim();
                if(!id) return;
                const str = localStorage.getItem(`vdt-calc-${id}`);
                if(str) {
                    const data = JSON.parse(str);
                    patientIdInput.value = id;
                    tableData = data.tableData || [];
                    newNoduleCheckbox.checked = data.isNewNodule || false;
                    logScaleCheckbox.checked = data.isLogScale || false;
                    predictionCheckbox.checked = data.isPrediction || false;
                    uniqueRowId = tableData.length > 0 ? Math.max(...tableData.map(d=>d.id)) + 1 : 0;
                    renderTable();
                }
            }
            function saveAndNew() { saveData(); clearAll(); }
            function exportToCSV() { /* ... */ }

            addScanBtn.addEventListener('click', addScan);
            clearBtn.addEventListener('click', clearAll);
            saveBtn.addEventListener('click', saveData);
            exportBtn.addEventListener('click', exportToCSV);
            exportNewBtn.addEventListener('click', saveAndNew);
            patientIdInput.addEventListener('blur', () => loadData());
            patientIdInput.addEventListener('keydown', (e) => { if(e.key==='Enter') loadData(); });
            sortOrderSelect.addEventListener('change', renderTable);
            newNoduleCheckbox.addEventListener('change', calculateAll);
            logScaleCheckbox.addEventListener('change', calculateAll);
            predictionCheckbox.addEventListener('change', calculateAll);
            managePatientsBtn.addEventListener('click', openPatientManager);
            modalCloseBtn.addEventListener('click', () => patientManagerModal.classList.add('hidden'));
            patientManagerModal.addEventListener('click', (e) => { if(e.target===patientManagerModal) patientManagerModal.classList.add('hidden'); });
            versionLogBtn.addEventListener('click', () => changelogModal.classList.remove('hidden'));
            changelogCloseBtn.addEventListener('click', () => changelogModal.classList.add('hidden'));
            changelogModal.addEventListener('click', (e) => { if(e.target===changelogModal) changelogModal.classList.add('hidden'); });
            patientSearchInput.addEventListener('input', openPatientManager);
            showStarredOnlyCheckbox.addEventListener('change', openPatientManager);
            showPositiveOnlyCheckbox.addEventListener('change', openPatientManager);
            showNewNoduleOnlyCheckbox.addEventListener('change', openPatientManager);
            document.addEventListener('mouseover', (e) => { if(e.target.classList.contains('tooltip-icon')) showTooltip(e.target, e.target.dataset.tooltip); });
            document.addEventListener('mouseout', (e) => { if(e.target.classList.contains('tooltip-icon')) hideTooltip(); });

            function initializeWithPreset() {
                createTooltip();
                const testId = "Version Test";
                if (!localStorage.getItem(`vdt-calc-${testId}`)) {
                    const dummyData = { tableData: [ { id: 1, date: '2023-01-15', solid: 45, core: 28, nonsolid: 15, isBaseline: true }, { id: 2, date: '2023-04-20', solid: 52, core: 32, nonsolid: 18, isBaseline: false }, { id: 3, date: '2024-01-18', solid: 68, core: 40, nonsolid: 25, isBaseline: false }, { id: 4, date: '2025-01-22', solid: 85, core: 50, nonsolid: 32, isBaseline: false } ], isNewNodule: false, isLogScale: false, isPrediction: true, isStarred: true, notes: "Auto-generated test case." };
                    localStorage.setItem(`vdt-calc-${testId}`, JSON.stringify(dummyData));
                }
                tableData = []; uniqueRowId = 0; for(let i=0; i<4; i++) addScan();
            }
            initializeWithPreset();
        };
    </script>
</body>
</html>
