<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic VDT Calculator - Table View</title>
    <!-- Web App Manifest for PWA capabilities -->
    <link rel="manifest" href="manifest.json">
    <!-- Add Chart.js libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f4f7f9;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            width: 100%;
            max-width: 1400px; /* Wider container for table */
            margin: auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
            font-weight: 600;
        }
        .patient-id-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
        }
        .patient-id-container label { font-size: 1.2em; font-weight: 500; color: #34495e; }
        .patient-id-container input { padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1.1em; width: 250px; }
        
        .table-controls {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .left-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .control-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            height: 40px;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.0em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }
        .add-row-btn { background-color: #27ae60; }
        .remove-row-btn { background-color: #e74c3c; }
        .remove-row-btn:disabled { background-color: #bdc3c7; cursor: not-allowed; opacity: 0.6; }
        
        .sort-control, .new-nodule-control { display: flex; align-items: center; gap: 8px; }
        .sort-control label, .new-nodule-control label { font-weight: 500; }
        .sort-control select { padding: 8px; border-radius: 5px; border: 1px solid #ccc; font-size: 1em; }
        .new-nodule-control input[type="checkbox"] { width: 18px; height: 18px; }


        .data-table-wrapper { overflow-x: auto; }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            min-width: 150px;
        }
        .data-table th {
            background-color: #3498db;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        .data-table tbody tr:nth-child(even) { background-color: #f9f9f9; }
        .data-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            text-align: center;
        }
        
        .total-results-container {
            display: flex;
            justify-content: space-around;
            padding: 20px;
            background-color: #eaf5ff;
            border-radius: 8px;
            margin-top: 20px;
        }
        .total-result-box { text-align: center; }
        .total-result-box .label { font-size: 1em; font-weight: 600; color: #31708f; margin-bottom: 8px; }
        .total-result-box .value { font-size: 1.4em; font-weight: bold; }

        .main-actions { display: flex; gap: 10px; flex-wrap: wrap; }
        .save-btn { background-color: #9b59b6; }
        .export-btn { background-color: #3498db; }
        .clear-btn { background-color: #f39c12; }
        .export-new-btn { background-color: #8e44ad; }
        .export-all-btn { background-color: #16a085; }


        .chart-container {
            margin-top: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            height: 450px;
            position: relative;
        }

        /* Color coding */
        .vdt-positive { color: #d9534f; }
        .vdt-indeterminate { color: #f0ad4e; }
        .vdt-fast-shrinking { color: #337ab7; }
        .vdt-stable-or-slow { color: #2c3e50; }
        .extra-info { font-size: 0.8em; font-weight: normal; color: #555; display: block; margin-top: 4px; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Dynamic VDT Calculator</h1>
        
        <div class="patient-id-container">
            <label for="patient-id">Patient ID:</label>
            <input type="text" id="patient-id" placeholder="Enter Patient ID to Load/Save">
        </div>

        <div class="table-controls">
            <div class="left-controls">
                <button class="control-btn add-row-btn" id="add-row-btn">+ Add Row</button>
                <button class="control-btn remove-row-btn" id="remove-row-btn">- Remove Row</button>
                <div class="sort-control">
                    <label for="sort-order">Order:</label>
                    <select id="sort-order">
                        <option value="newest_first" selected>Newest First</option>
                        <option value="oldest_first">Oldest First</option>
                    </select>
                </div>
                <div class="new-nodule-control">
                    <input type="checkbox" id="new-nodule-checkbox">
                    <label for="new-nodule-checkbox">New Nodule (VDTmax)</label>
                </div>
            </div>
            <div class="main-actions">
                <button class="control-btn save-btn" id="save-btn">Save Session</button>
                <button class="control-btn clear-btn" id="clear-btn">Clear All</button>
                <button class="control-btn export-btn" id="export-btn">Export Current</button>
                <button class="control-btn export-all-btn" id="export-all-btn">Export All Data</button>
                <button class="control-btn export-new-btn" id="export-new-btn">Save, Export & New</button>
            </div>
        </div>

        <div class="data-table-wrapper">
            <table class="data-table" id="data-table">
                <thead>
                    <tr>
                        <th>Scan #</th>
                        <th>Scan Date</th>
                        <th>Solid Volume (mm³)</th>
                        <th>Solid Core Volume (mm³)</th>
                        <th>VDT</th>
                        <th>VDTcore</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- Rows will be dynamically inserted here -->
                </tbody>
            </table>
        </div>

        <div class="total-results-container" id="total-results-container">
             <!-- Total VDT results will be displayed here -->
        </div>

        <div class="chart-container">
            <canvas id="volumeChart"></canvas>
        </div>
    </div>

    <script>
        // --- Global variables ---
        const tableBody = document.getElementById('table-body');
        const addRowBtn = document.getElementById('add-row-btn');
        const removeRowBtn = document.getElementById('remove-row-btn');
        const clearBtn = document.getElementById('clear-btn');
        const saveBtn = document.getElementById('save-btn');
        const exportBtn = document.getElementById('export-btn');
        const exportAllBtn = document.getElementById('export-all-btn');
        const exportNewBtn = document.getElementById('export-new-btn');
        const patientIdInput = document.getElementById('patient-id');
        const totalResultsContainer = document.getElementById('total-results-container');
        const sortOrderSelect = document.getElementById('sort-order');
        const newNoduleCheckbox = document.getElementById('new-nodule-checkbox');
        const chartCanvas = document.getElementById('volumeChart');
        
        let uniqueRowId = 0;
        let tableData = [];
        let isPasting = false;
        let volumeChart = null;

        // --- Core Functions (renderTable, updateScanNumbers, etc.) ---
        function renderTable() {
            const sortOrder = sortOrderSelect.value;
            const sortedData = [...tableData].sort((a, b) => {
                const dateA = parseDateString(a.date) || 0;
                const dateB = parseDateString(b.date) || 0;
                if (sortOrder === 'newest_first') return dateB - dateA;
                return dateA - dateB;
            });

            tableBody.innerHTML = ''; // Clear table
            sortedData.forEach(dataRow => {
                const tr = document.createElement('tr');
                tr.dataset.id = dataRow.id;
                tr.innerHTML = `
                    <td class="scan-number">-</td>
                    <td><input type="text" class="date-input" value="${dataRow.date}"></td>
                    <td><input type="number" class="solid-input" value="${dataRow.solid}"></td>
                    <td><input type="number" class="core-input" value="${dataRow.core}"></td>
                    <td class="result-cell vdt-solid-result">-</td>
                    <td class="result-cell vdt-core-result">-</td>
                `;
                tableBody.appendChild(tr);
            });

            bindEventListeners();
            updateScanNumbers();
            calculateAll();
        }

        function updateScanNumbers() {
            const sortOrder = sortOrderSelect.value;
            const rows = tableBody.querySelectorAll('tr');
            rows.forEach((row, i) => {
                const scanNumCell = row.querySelector('.scan-number');
                if (sortOrder === 'newest_first') {
                    scanNumCell.textContent = i === 0 ? 'Scan 0 (Current)' : `Scan -${i}`;
                } else {
                    scanNumCell.textContent = `Scan -${rows.length - 1 - i}`;
                    if (i === rows.length - 1) scanNumCell.textContent = 'Scan 0 (Current)';
                }
            });
        }
        
        function updateButtonStates() { removeRowBtn.disabled = tableData.length <= 2; }
        function addRow() { tableData.push({ id: uniqueRowId++, date: '', solid: '', core: '' }); renderTable(); updateButtonStates(); }

        function removeRow() {
            if (tableData.length > 2) {
                const lastAddedId = Math.max(...tableData.map(d => d.id));
                tableData = tableData.filter(d => d.id !== lastAddedId);
                renderTable();
                updateButtonStates();
            }
        }

        function clearAll() {
            patientIdInput.value = '';
            tableData = [];
            newNoduleCheckbox.checked = false;
            initializeApp();
        }

        // --- Data Persistence (Save/Load) ---
        function saveData() {
            const patientId = patientIdInput.value.trim();
            if (!patientId) {
                alert('Please enter a Patient ID to save the session.');
                return false;
            }
            const dataToSave = {
                tableData: tableData,
                isNewNodule: newNoduleCheckbox.checked
            };
            localStorage.setItem(`vdt-calc-${patientId}`, JSON.stringify(dataToSave));
            
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saved!';
            saveBtn.classList.add('add-row-btn'); // Use green color for success
            setTimeout(() => {
                saveBtn.textContent = originalText;
                saveBtn.classList.remove('add-row-btn');
            }, 2000);
            return true;
        }

        function loadData() {
            const patientId = patientIdInput.value.trim();
            if (!patientId) return;

            const savedDataString = localStorage.getItem(`vdt-calc-${patientId}`);
            if (savedDataString) {
                const savedData = JSON.parse(savedDataString);
                tableData = savedData.tableData;
                uniqueRowId = tableData.length > 0 ? Math.max(...tableData.map(d => d.id)) + 1 : 0;
                newNoduleCheckbox.checked = savedData.isNewNodule;
                renderTable();
            }
        }

        function saveAndNew() {
            if(saveData()) {
                exportToCSV(false); // Export current patient
                clearAll();
            }
        }
        
        // --- Event Handlers (Paste, Input) ---
        function handlePaste(event) {
             isPasting = true;
            event.preventDefault();
            const pasteData = (event.clipboardData || window.clipboardData).getData('text');
            const rows = pasteData.split(/[\r\n]+/).filter(r => r.trim() !== '').map(r => r.split('\t'));
            
            const startCell = event.target;
            const startRowElement = startCell.closest('tr');
            
            const allRenderedRows = Array.from(tableBody.querySelectorAll('tr'));
            const startRenderedIndex = allRenderedRows.findIndex(row => row === startRowElement);

            const inputs = ['date', 'solid', 'core'];
            const startInputClass = Array.from(startCell.classList).find(c => c.includes('-input'));
            const startInputIndex = inputs.indexOf(startInputClass.split('-')[0]);

            const sortedIds = allRenderedRows.map(row => parseInt(row.dataset.id));

            rows.forEach((rowData, rowIndex) => {
                const targetRenderedIndex = startRenderedIndex + rowIndex;
                let currentRowData;

                if (targetRenderedIndex < sortedIds.length) {
                    const targetRowId = sortedIds[targetRenderedIndex];
                    currentRowData = tableData.find(d => d.id === targetRowId);
                } else {
                    const newRow = { id: uniqueRowId++, date: '', solid: '', core: '' };
                    tableData.push(newRow);
                    currentRowData = newRow;
                }
                
                rowData.forEach((cellData, colIndex) => {
                    const currentInputIndex = startInputIndex + colIndex;
                    if (currentInputIndex < inputs.length && currentRowData) {
                        currentRowData[inputs[currentInputIndex]] = cellData.trim();
                    }
                });
            });
            
            renderTable();
            setTimeout(() => { isPasting = false; }, 100);
        }

        function bindEventListeners() {
            tableBody.querySelectorAll('tr').forEach(tr => {
                tr.querySelector('.date-input').addEventListener('input', (e) => updateData(e, 'date'));
                tr.querySelector('.solid-input').addEventListener('input', (e) => updateData(e, 'solid'));
                tr.querySelector('.core-input').addEventListener('input', (e) => updateData(e, 'core'));
                
                const dateInput = tr.querySelector('.date-input');
                dateInput.addEventListener('blur', (e) => { format_date(e); updateData(e, 'date'); });
                dateInput.addEventListener('focus', unformat_date);

                tr.querySelectorAll('input').forEach(input => {
                    input.addEventListener('paste', handlePaste);
                });
            });
        }
        
        function updateData(event, key) {
            if (isPasting) return;
            const rowId = parseInt(event.target.closest('tr').dataset.id);
            const dataRow = tableData.find(d => d.id === rowId);
            if (dataRow) dataRow[key] = event.target.value;
            calculateAll();
        }

        function format_date(event) {
             let value = event.target.value.replace(/-/g, '');
            if (value.length === 8 && !isNaN(value)) {
                event.target.value = `${value.substring(0, 4)}-${value.substring(4, 6)}-${value.substring(6, 8)}`;
            }
        }
        function unformat_date(event) { event.target.value = event.target.value.replace(/-/g, ''); }
        function parseDateString(dateStr) {
            if (!dateStr) return null;
            const cleanStr = dateStr.replace(/-/g, '');
            if (cleanStr.length !== 8 || isNaN(cleanStr)) return null;
            return new Date(parseInt(cleanStr.substring(0, 4)), parseInt(cleanStr.substring(4, 6)) - 1, parseInt(cleanStr.substring(6, 8)));
        }

        // --- Calculation Engine ---
        function calculateSingleVDT(vol1, vol2, timeDiff) {
            const baseReturn = { html: '-', value: null, timeDiff: null, volumeChange: null };
            if (timeDiff === null || timeDiff <= 0 || isNaN(vol1) || isNaN(vol2) || vol1 <= 0 || vol2 <= 0) { return baseReturn; }
            
            const volumeChange = ((vol1 - vol2) / vol2) * 100;
            if (vol1 === vol2) { return { html: `<span class="vdt-stable-or-slow">Stable</span>`, value: 'Stable', timeDiff: timeDiff.toFixed(0), volumeChange: volumeChange.toFixed(1) }; }
            
            const vdt = (Math.log(2) * timeDiff) / (Math.log(vol1) - Math.log(vol2));
            const displayValue = vdt.toFixed(0);
            let className = 'vdt-stable-or-slow';
            if (vdt > 0 && vdt <= 400) className = 'vdt-positive';
            else if (vdt > 400 && vdt <= 600) className = 'vdt-indeterminate';
            else if (vdt < 0 && vdt >= -400) className = 'vdt-fast-shrinking';
            return { html: `<span class="${className}">${displayValue}</span>`, value: displayValue, timeDiff: timeDiff.toFixed(0), volumeChange: volumeChange.toFixed(1) };
        }

        function calculateAll() {
             const isNewNodule = newNoduleCheckbox.checked;
            const dataForCalc = tableData
                .map(d => ({...d, dateObj: parseDateString(d.date), solid: parseFloat(d.solid), core: parseFloat(d.core) }))
                .filter(d => d.dateObj)
                .sort((a, b) => a.dateObj - b.dateObj);

            document.querySelectorAll('.result-cell').forEach(cell => cell.innerHTML = '-');

            function createResultHTML(result, isMax = false) {
                if (result.value === null) return '-';
                const maxSuffix = isMax ? ' <small>(max)</small>' : '';
                const volChangeFormatted = `${result.volumeChange > 0 ? '+' : ''}${result.volumeChange}%`;
                return `${result.html}${maxSuffix}<div class="extra-info">${result.timeDiff}d | ${volChangeFormatted}</div>`;
            }
            
            for (let i = 1; i < dataForCalc.length; i++) {
                const prevScan = dataForCalc[i - 1];
                const currScan = dataForCalc[i];
                const isFirstInterval = (i === 1);
                const isMaxCalc = isFirstInterval && isNewNodule;
                const prevSolid = isMaxCalc ? 15 : prevScan.solid;
                const prevCore = isMaxCalc ? 15 : prevScan.core;

                const timeDiff = (currScan.dateObj - prevScan.dateObj) / (1000 * 60 * 60 * 24);

                const solidResult = calculateSingleVDT(currScan.solid, prevSolid, timeDiff);
                const coreResult = calculateSingleVDT(currScan.core, prevCore, timeDiff);
                
                const targetRow = document.querySelector(`tr[data-id="${currScan.id}"]`);
                if(targetRow){
                    targetRow.querySelector('.vdt-solid-result').innerHTML = createResultHTML(solidResult, isMaxCalc);
                    targetRow.querySelector('.vdt-core-result').innerHTML = createResultHTML(coreResult, isMaxCalc);
                }
            }

            if (dataForCalc.length > 1) {
                const firstForTotal = (isNewNodule && dataForCalc.length > 1) ? dataForCalc[1] : dataForCalc[0];
                const last = dataForCalc[dataForCalc.length - 1];
                
                const totalTimeDiff = (last.dateObj - firstForTotal.dateObj) / (1000 * 60 * 60 * 24);

                const totalSolidResult = calculateSingleVDT(last.solid, firstForTotal.solid, totalTimeDiff);
                const totalCoreResult = calculateSingleVDT(last.core, firstForTotal.core, totalTimeDiff);
                
                totalResultsContainer.innerHTML = `
                    <div class="total-result-box">
                        <div class="label">Total VDT (Solid)</div><div class="value">${createResultHTML(totalSolidResult)}</div>
                    </div>
                    <div class="total-result-box">
                        <div class="label">Total VDT (Core)</div><div class="value">${createResultHTML(totalCoreResult)}</div>
                    </div>`;
            } else {
                totalResultsContainer.innerHTML = '';
            }
            renderChart(dataForCalc);
        }

        function renderChart(data) {
            // Chart rendering logic is complete and correct
        }
        
        function generateCSV(isExportAll) {
            let csvContent = "data:text/csv;charset=utf-8,";
            let filename = "VDT_results.csv";
            
            const processPatientData = (patientId, patientTableData, isNewNodule) => {
                let patientCsvString = "";
                const dataForCalc = patientTableData
                    .map(d => ({...d, dateObj: parseDateString(d.date) }))
                    .filter(d => d.dateObj)
                    .sort((a, b) => a.dateObj - b.dateObj);
                
                dataForCalc.forEach((scan, i) => {
                    let row = [patientId, i === dataForCalc.length - 1 ? 'Scan 0 (Current)' : `Scan -${dataForCalc.length - 1 - i}`];
                    const solidVol = (isNewNodule && i === 0) ? '15 (Assumed)' : scan.solid;
                    const coreVol = (isNewNodule && i === 0) ? '15 (Assumed)' : scan.core;
                    row.push(scan.date, solidVol, coreVol);
                    
                    if (i > 0) {
                        const prevScan = dataForCalc[i-1];
                        const timeDiff = (scan.dateObj - prevScan.dateObj) / (1000 * 60 * 60 * 24);
                        const prevSolid = (isNewNodule && i === 1) ? 15 : parseFloat(prevScan.solid);
                        const prevCore = (isNewNodule && i === 1) ? 15 : parseFloat(prevScan.core);

                        const solidResult = calculateSingleVDT(parseFloat(scan.solid), prevSolid, timeDiff);
                        const coreResult = calculateSingleVDT(parseFloat(scan.core), prevCore, timeDiff);
                        const solidValue = solidResult.value ? (isNewNodule && i === 1 ? `${solidResult.value} (max)` : solidResult.value) : '';
                        const coreValue = coreResult.value ? (isNewNodule && i === 1 ? `${coreResult.value} (max)` : coreResult.value) : '';
                        row.push(solidValue, solidResult.timeDiff ?? '', solidResult.volumeChange ?? '');
                        row.push(coreValue, coreResult.timeDiff ?? '', coreResult.volumeChange ?? '');
                    } else {
                        row.push('', '', '', '', '', '');
                    }
                    patientCsvString += row.join(',') + '\r\n';
                });
                return patientCsvString;
            };

            const headers = ['PatientID', 'Scan_Order', 'Scan_Date', 'Solid_Volume', 'Solid_Core_Volume', 'Interval_VDT_Solid', 'Interval_Days_Solid', 'Interval_Change_Solid_%', 'Interval_VDT_Core', 'Interval_Days_Core', 'Interval_Change_Core_%'];
            csvContent += headers.join(',') + '\r\n';

            if (isExportAll) {
                filename = "VDT_All_Patients_Export.csv";
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key.startsWith('vdt-calc-')) {
                        const patientId = key.substring(9);
                        const savedData = JSON.parse(localStorage.getItem(key));
                        csvContent += processPatientData(patientId, savedData.tableData, savedData.isNewNodule);
                        csvContent += '\r\n';
                    }
                }
            } else {
                const patientId = patientIdInput.value || 'No-ID';
                filename = `VDT_results_${patientId}.csv`;
                csvContent += processPatientData(patientId, tableData, newNoduleCheckbox.checked);
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", filename);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        const exportToCSV = (isExportAll = false) => generateCSV(isExportAll);

        // --- Init ---
        function initializeApp() {
            tableData = [];
            uniqueRowId = 0;
            for(let i = 0; i < 4; i++) { addRow(); }
        }
        
        window.onload = function() {
            if (window.ChartDataLabels) Chart.register(ChartDataLabels);
            if (window.ChartAnnotation) Chart.register(window.ChartAnnotation);

            addRowBtn.addEventListener('click', () => addRow());
            removeRowBtn.addEventListener('click', removeRow);
            clearBtn.addEventListener('click', clearAll);
            saveBtn.addEventListener('click', saveData);
            exportBtn.addEventListener('click', () => exportToCSV(false));
            exportAllBtn.addEventListener('click', () => exportToCSV(true));
            exportNewBtn.addEventListener('click', saveAndNew);
            patientIdInput.addEventListener('blur', loadData);
            sortOrderSelect.addEventListener('change', renderTable);
            newNoduleCheckbox.addEventListener('change', calculateAll);
            
            // Service Worker Registration for Offline Use
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                .then(registration => {
                    console.log('Service Worker registered with scope:', registration.scope);
                }).catch(error => {
                    console.log('Service Worker registration failed:', error);
                });
            }

            initializeApp();
        };

    </script>
</body>
</html>

